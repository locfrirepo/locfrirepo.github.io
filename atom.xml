<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Xinnyu's blog]]></title>
  <subtitle><![CDATA[Walk steps step by step]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xinnyu.com/"/>
  <updated>2015-10-15T08:19:34.000Z</updated>
  <id>http://xinnyu.com/</id>
  
  <author>
    <name><![CDATA[xinnyu]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Swift 中泛型的使用]]></title>
    <link href="http://xinnyu.com/2015/10/15/Swift-%E4%B8%AD%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://xinnyu.com/2015/10/15/Swift-中泛型的使用/</id>
    <published>2015-10-15T07:09:58.000Z</published>
    <updated>2015-10-15T08:19:34.000Z</updated>
    <content type="html"><![CDATA[<p>对于类型安全(type-safe)语言，一个常见的问题就是如何编写适用于多种类型输入的程序。想象一下，两个整型数相加和两个浮点数相加的程序看起来应该非常类似，甚至一模一样才对。唯一的区别就是变量的类型不同。</p>
<p>在强类型语言中，你需要去定义诸如addInts, addFloats, addDoubles 等方法来正确地处理参数及返回值。</p>
<p>许多编程语言已经解决了这个问题。例如，在C++中，使用Template来解决。而Swift，Java和C#则采用了泛型来解决这个问题。</p>
<p>下面用有序字典（Ordered Dictionaries）来简单说明一下泛型的用法：</p>
<p>和数组不同的是，包括Swift在内地很多编程语言和框架都不保证集合(sets)和字典(dictionaries)的数据存储顺序。有序字典和普通的字典类似，不同之处在于它的key是有序的。</p>
<h4 id="创建有序字典">创建有序字典</h4><p>点击“文件\新建\文件…”新建一个文件，并选择“IOS\Source\Swift File”。点击“下一步”并把这个文件命名为“OrderedDictionary”。最后，点击“创建”。</p>
<p>你会得到一个空的Swift文件，加这样一段代码进去：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct OrderedDictionary &#123;  &#10;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>到现在为止应该都没有什么问题。通过语义可以看出这个对象是一个结构体。</p>
<p>现在你需要将其一般化，以便它能够装载你需要的任何类型的数据。通过下列改变你对Swift中“结构”的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct OrderedDictionary&#60;KeyType, ValueType&#62;</span><br></pre></td></tr></table></figure>
<p>在尖括弧中的元素是通用类型的参数。KeyType和ValueType不是他们自身的类型，而是你可以使用在结构里定义取代的类型。现在就简洁清新许多了！</p>
<p>最简单的实现一个有顺序的字典是保持一个数组和一个字典。字典中将会装载衍射，而数组将装载keys的顺序。</p>
<p>在结构体内部的定义中，加入以下的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typealias ArrayType = [KeyType]&#10;typealias DictionaryType = [KeyType: ValueType] &#10;var array = ArrayType()&#10;var dictionary = DictionaryType()</span><br></pre></td></tr></table></figure>
<p>这样声明有两个目的，就像上例描述的，有两种类型的用于给已经存在的类型的取新的名称的别名。在这，你将分别地为后面的数组和字典赋值了别名。声明别名是将复杂类型定义为更短名称的类型的一种非常有效的方式。</p>
<p>你将注意怎么样从结构体中定义用“KeyType”和“ValueType”的参数类型中替换类型。上例的”KeyTypes”是数组类型的。当然这是没有这样的类型的“KeyType”；当在一般的实例化时，将替代Swift像对OrderedDictionary的类型的一切类型通过。</p>
<p>就因为这样，你将会注意到编译错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Type &#39;Keytype&#39; does not conform to protocol &#39;Hashable&#39;</span><br></pre></td></tr></table></figure>
<p>这是因为你的字典Key没有遵循Hashable协议； 我们可以手动修改代码让Key遵循Hashable协议：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct OrderedDictionary&#60;KeyType: Hashable, ValueType</span><br></pre></td></tr></table></figure>
<p>接下来我们就需要正式建立有序字典了；</p>
<ul>
<li>添加count属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var count: Int &#123;&#10;    return self.array.count&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加插入和移除方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mutating func removeAtIndex(index: Int) -&#62; (KeyType, ValueType) &#123;&#10;    precondition(index &#60; self.array.count, &#34;Index &#36229;&#20986;&#33539;&#22260;&#34;)&#10;    assert(index &#60; self.array.count)&#10;    &#10;    let key = self.array.removeAtIndex(index)&#10;    &#10;    let value = self.dictionary.removeValueForKey(key)!&#10;    &#10;    return (key, value)&#10;&#125;&#10;&#10;mutating func insert(value: ValueType, forKey key: KeyType, atIndex index:Int) -&#62; ValueType? &#123;&#10;    var adjustedIndex = index&#10;    &#10;    let existingValue = self.dictionary[key]&#10;    &#10;    if existingValue != nil &#123;&#10;        let existingIndex = self.array.indexOf(key)&#10;        &#10;        if existingIndex &#60; index &#123;&#10;            adjustedIndex--&#10;        &#125;&#10;        &#10;        self.array.removeAtIndex(existingIndex!)&#10;    &#125;&#10;    &#10;    self.array.insert(key, atIndex: adjustedIndex)&#10;    self.dictionary[key] = value&#10;    &#10;    return existingValue&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>注意在结构体内如果方法需要修改结构体内的属性的话，要在方法前加mutating关键字；</p>
<ul>
<li>添加下标访问方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">subscript(key: KeyType) -&#62; ValueType? &#123;&#10;    get &#123;&#10;        return self.dictionary[key]&#10;    &#125;&#10;    &#10;    set &#123;&#10;        if let _ = self.array.indexOf(key) &#123;&#125;else &#123;&#10;            self.array.append(key)&#10;        &#125;&#10;        &#10;        self.dictionary[key] = newValue&#10;    &#125;&#10;&#125;&#10;&#10;subscript(index: Int) -&#62;(KeyType, ValueType) &#123;&#10;    get &#123;&#10;        precondition(index &#60; self.array.count, &#34;Index &#36229;&#20986;&#33539;&#22260;&#34;)&#10;        &#10;        let key = self.array[index]&#10;        &#10;        let value = self.dictionary[key]!&#10;        &#10;        return (key, value)&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<pre><code>这样我们就利用泛型创建了一个有序字典。
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>对于类型安全(type-safe)语言，一个常见的问题就是如何编写适用于多种类型输入的程序。想象一下，两个整型数相加和两个浮点数相加的程序看起来应该非常类似，甚至一模一样才对。唯一的区别就是变量的类型不同。</p>
<p>在强类型语言中，你需要去定义诸如addInts, a]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift单例]]></title>
    <link href="http://xinnyu.com/2015/10/15/Swift%E5%8D%95%E4%BE%8B/"/>
    <id>http://xinnyu.com/2015/10/15/Swift单例/</id>
    <published>2015-10-15T06:58:10.000Z</published>
    <updated>2015-10-15T13:45:21.000Z</updated>
    <content type="html"><![CDATA[<p>单例是一个在 Cocoa 中很常用的模式了。对于一些希望能在全局方便访问的实例，或者在 app 的生命周期中只应该存在一个的对象，我们一般使用单例来存储和访问。在 Objective-C 中单例的公认的写法类似下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation MyManager&#10;+ (id)sharedManager &#123;&#10;    static MyManager *staticInstance = nil;&#10;    static dispatch_once_t onceToken;&#10;&#10;    dispatch_once(&#38;onceToken, ^&#123;&#10;        staticInstance = [[self alloc] init];&#10;    &#125;);&#10;    return staticInstance;&#10;&#125;&#10;@end</span><br></pre></td></tr></table></figure>
<p>使用 GCD 中的 dispatch_once_t 可以保证里面的代码只被调用一次，以此保证单例在线程上的安全。</p>
<p>因为在 Swift 中可以无缝直接使用 GCD，所以我们可以很方便地把类似方式的单例用 Swift 进行改写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyManager &#123;&#10;    class var sharedManager : MyManager &#123;&#10;        struct Static &#123;&#10;            static var onceToken : dispatch_once_t = 0&#10;            static var staticInstance : MyManager? = nil&#10;        &#125;&#10;&#10;        dispatch_once(&#38;Static.onceToken) &#123;&#10;            Static.staticInstance = MyManager()&#10;        &#125;&#10;&#10;        return Static.staticInstance!&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>因为 Swift 现在还暂时不支持存储的 class var，所以我们需要使用一个 struct 来存储类型变量。</p>
<p>这样的写法当然没什么问题，但是在 Swift 里我们其实有一个更简单的保证线程安全的方式，那就是 let。把上面的写法简化一下，可以变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyManager &#123;&#10;    class var sharedManager : MyManager &#123;&#10;        struct Static &#123;&#10;            static let sharedInstance : MyManager = MyManager()&#10;        &#125;&#10;&#10;        return Static.sharedInstance&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>还有另一种更受大家欢迎，并被认为是当前的最佳实践的做法。由于现在 class 不支持存储式的 property，我们想要使用一个只存在一份的属性时，就只能将其定义在全局的 scope 中。值得庆幸的是，在 Swift 拥有访问级别控制后，我们可以在变量定义前面加上 private 关键字，使这个变量只在当前文件中可以被访问。这样我们就可以写出一个没有嵌套的，语法上也更简单好看的单例了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private let sharedInstance = MyManager()&#10;&#10;class MyManager  &#123;&#10;    class var sharedManager : MyManager &#123;&#10;        return sharedInstance&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>最后一种是最简单也是最实用的，是swift给的语法糖</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>单例是一个在 Cocoa 中很常用的模式了。对于一些希望能在全局方便访问的实例，或者在 app 的生命周期中只应该存在一个的对象，我们一般使用单例来存储和访问。在 Objective-C 中单例的公认的写法类似下面这样：</p>
<figure class="highlig]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式]]></title>
    <link href="http://xinnyu.com/2015/09/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xinnyu.com/2015/09/29/设计模式/</id>
    <published>2015-09-29T06:52:05.000Z</published>
    <updated>2015-09-29T16:16:34.000Z</updated>
    <content type="html"><![CDATA[<p>设计模式是为了解决特定问题而出现的；</p>
<p>设计模式的基本原则：</p>
<ul>
<li><p>开闭原则<br>模块应该对扩展开放而对修改关闭；</p>
</li>
<li><p>里氏代换原则<br>父类和子类之间的方法可以相互调换，从而方便修改；多态</p>
</li>
<li><p>依赖倒转原则<br>抽象不依赖于细节，细节依赖于抽象；</p>
</li>
<li><p>接口隔离原则<br>尽量保证接口只做必要的事情；</p>
</li>
<li><p>合成/聚合复用</p>
</li>
</ul>
<h3 id="适配器模式">适配器模式</h3><p>比如iOS从网络请求加载数据，更新UI的时候，我们会初始化出一个model，随着后续版本的升级，这个model会持续添加参数，或者减少参数；此时如果我们直接修改这个model的话，那么就要同时修改与这个model相匹配的view，这样就会一只在两者之间修改来修改去，适配器模式就是为了解决这种问题存在的。</p>
<p>如果你运用了适配器模式，那么我们的model不会直接与view接触，它会先和适配器接触，然后再通过适配器去更新UI</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>设计模式是为了解决特定问题而出现的；</p>
<p>设计模式的基本原则：</p>
<ul>
<li><p>开闭原则<br>模块应该对扩展开放而对修改关闭；</p>
</li>
<li><p>里氏代换原则<br>父类和子类之间的方法可以相互调换，从而方便修改；多态</p>
<]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac终端command not found 解决办法]]></title>
    <link href="http://xinnyu.com/2015/09/26/Mac%E7%BB%88%E7%AB%AF%E6%8F%90%E7%A4%BA-command-not-found%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://xinnyu.com/2015/09/26/Mac终端提示-command-not-found解决办法/</id>
    <published>2015-09-26T14:37:57.000Z</published>
    <updated>2015-09-26T15:17:27.000Z</updated>
    <content type="html"><![CDATA[<p>在bash_profile中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=&#34;$PATH:$HOME/.rvm/bin&#34; # Add RVM to PATH for scripting&#10;&#10;[[ -s &#34;$HOME/.rvm/scripts/rvm&#34; ]] &#38;&#38; source &#34;$HOME/.rvm/scripts/rvm&#34; # Load RVM into a shell session *as a function*</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>在bash_profile中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=&#34;$PATH:$HOME/.r]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac自带Vim7.3不能使用系统剪切板解决方案]]></title>
    <link href="http://xinnyu.com/2015/09/26/Mac%E8%87%AA%E5%B8%A6Vim7-3%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%89%AA%E5%88%87%E6%9D%BF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://xinnyu.com/2015/09/26/Mac自带Vim7-3不能使用系统剪切板解决方案/</id>
    <published>2015-09-26T11:35:44.000Z</published>
    <updated>2015-09-26T14:33:39.000Z</updated>
    <content type="html"><![CDATA[<p>用了Mac自带的Vim之后发现yy复制的内容和剪切板不同步，谷歌之，找到2种方法：</p>
<ul>
<li>“+y </li>
<li>在 ~/.vimrc 里增加 set clipboard=unnamed</li>
</ul>
<p>但是完全不起任何作用，经过一番折腾之后才知道是Mac自带的Vim7.3版本不支持使用系统剪切板；<br>于是就安装了MacVim，结果试了之后还是不管用，执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim --version | grep clip</span><br></pre></td></tr></table></figure></p>
<p>结果还是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-clientserver -clipboard +cmdline_compl +cmdline_hist +cmdline_info +comments &#10;-xterm_clipboard -xterm_save</span><br></pre></td></tr></table></figure>
<p>原因是就算你安装了MacVim使用了Vim7.4系统自带的Terminal还是会默认使用自带的7.3版本；</p>
<p>所以只要在profile中添加如下语句就可以解决问题了；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias vim=&#34;/Applications/MacVim.app/Contents/MacOS/Vim&#34;</span><br></pre></td></tr></table></figure>
<p>之后你在终端使用vim也会调用MacVim中的7.4版本了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>用了Mac自带的Vim之后发现yy复制的内容和剪切板不同步，谷歌之，找到2种方法：</p>
<ul>
<li>“+y </li>
<li>在 ~/.vimrc 里增加 set clipboard=unnamed</li>
</ul>
<p>但是完全不起任何作用，经过一番折腾]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Dynamics动画]]></title>
    <link href="http://xinnyu.com/2015/09/26/Dynamics%E5%8A%A8%E7%94%BB/"/>
    <id>http://xinnyu.com/2015/09/26/Dynamics动画/</id>
    <published>2015-09-25T17:29:21.000Z</published>
    <updated>2015-09-26T17:34:58.000Z</updated>
    <content type="html"><![CDATA[<p>UIKit Dynamics是iOS7中新推出的，可以模拟现实的二维动画效果，开发出逼真的物理动画。</p>
<h3 id="关键类">关键类</h3><ul>
<li>UIDynamicAnimator：封装了底层的物理引擎，为动力项（UIDynamicItem）提供物理相关的功能和动画；</li>
<li>UIDynamicBehavior，动力行为，为动力项提供不同的物理行为；</li>
<li>UIDynamicItem，动力项，相当于现实世界中的一个基本物体；</li>
</ul>
<h3 id="使用方法">使用方法</h3><ul>
<li>创建一个UIDynamicAnimator</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property(strong, nonatomic) UIDynamicAnimator *dynamicAnimate;&#10;&#10;- (UIDynamicAnimator *)dynamicAnimate&#123;&#10;    if (!_dynamicAnimate) &#123;&#10;        _dynamicAnimate = [[UIDynamicAnimator alloc] initWithReferenceView:self.gameView];&#10;        _dynamicAnimate.delegate = self;&#10;    &#125;&#10;    return _dynamicAnimate;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后就可以把动力行为加到动画中了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self.dynamicAnimate addBehavior:_dropItemBehavior];</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>UIKit Dynamics是iOS7中新推出的，可以模拟现实的二维动画效果，开发出逼真的物理动画。</p>
<h3 id="关键类">关键类</h3><ul>
<li>UIDynamicAnimator：封装了底层的物理引擎，为动力项（UIDynamicItem）提供物理]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用融云和LeanCloud 创建一个IM应用]]></title>
    <link href="http://xinnyu.com/2015/09/21/%E4%BD%BF%E7%94%A8%E8%9E%8D%E4%BA%91%E5%92%8CLeanCloud-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAIM%E5%BA%94%E7%94%A8/"/>
    <id>http://xinnyu.com/2015/09/21/使用融云和LeanCloud-创建一个IM应用/</id>
    <published>2015-09-20T17:39:23.000Z</published>
    <updated>2015-09-21T06:29:43.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.rongcloud.cn/" target="_blank" rel="external">融云</a> 是国内一家专门为APP开发者提供IM服务的公司，利用它提供的SDK可以快速使你的APP集成IM通讯能力。<br>详细的使用方法在它官网的开发文档中有提供，但是不得不吐槽的就是它的开发文档写的实在太乱了让人有种无从下手的感觉，下面简单记录一下使用过程。</p>
<h3 id="导入SDK">导入SDK</h3><p>推荐使用CocoaPods导入：</p>
<ol>
<li>在Podfile中添加：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &#39;RongCloudIMKit&#39;</span><br></pre></td></tr></table></figure>
<ol>
<li>然后执行命令：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure>
<h3 id="获取Token">获取Token</h3><p>Token 也叫用户令牌，是 SDK 端用来连接融云服务器的凭证，每个用户连接服务器都需要一个 Token。每次初始化连接服务器时，都需要向服务器提交 Token。<br>获取Token需要注册一个融云的账号，然后新建一个应用，之后在API调试中填写userid（用户唯一标示符）、name（用户昵称）、portraitUri（头像url）就可以获得一个测试用的Token。</p>
<h3 id="初始化和测试连接">初始化和测试连接</h3><p>获得测试用的Token之后就可以利用AppKey（创建应用时融云给你的应用标示符）和Token对应用进行初始化了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//&#29992;AppKey&#21021;&#22987;&#21270;     RCIM.sharedRCIM().initWithAppKey(&#34;82hegw5uh4r8x&#34;)      &#10;//&#29992;Token&#27979;&#35797;&#36830;&#25509;&#10;RCIM.sharedRCIM().connectWithToken(token, success: &#123; (str:String!) -&#62; Void in&#10;&#9;print(&#34;&#36830;&#25509;&#25104;&#21151;&#65281;&#34;)       &#10;  //&#36830;&#25509;&#25104;&#21151;&#21518;&#35774;&#32622;&#24403;&#21069;&#30331;&#38470;&#29992;&#25143;&#20449;&#24687;&#10;&#9;RCIMClient.sharedRCIMClient().currentUserInfo = RCUserInfo(userId: id, name: name, portrait: avatorURL)&#10;            &#10;&#9;//&#22312;UserDefaults&#20013;&#20445;&#23384;Token &#10;&#9;NSUserDefaults.standardUserDefaults().setObject(token, forKey: &#34;kDeviceToken&#34;)&#10;&#9;//&#22312;&#20027;&#32447;&#31243;&#20013;&#35843;&#29992;&#26356;&#26032;UI&#10;  dispatch_async(dispatch_get_main_queue(), &#123; () -&#62; Void in&#10;                &#10;&#9;&#125;)&#125;,&#10;&#9;error: &#123; (_) -&#62; Void in&#10;&#9;&#9;print(&#34;&#36830;&#25509;&#38169;&#35823;&#65281;&#34;)&#10;&#9;&#125;)&#10;&#9;&#123; () -&#62; Void in&#10;&#9;&#9;print(&#34;Token&#19981;&#27491;&#30830;&#65281;&#34;)&#10;&#9;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连接成功后启动单聊会话">连接成功后启动单聊会话</h3><p>融云在它的SDK中已经集成聊天用户界面，所以我们只要创建一个RCConversationViewController的实例就能使用它提供的用户界面了，同时用户界面也支持自定义，这部分在官网的开发文档中有详细的介绍，这里就不做赘述。<br>需要注意的是：要使用RCConversationViewController，必须给它的几个属性赋值：</p>
<ul>
<li>conversationType：聊天类型，有单聊、群聊等等</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.conversationType = RCConversationType.ConversationType_PRIVATE //&#36825;&#37324;&#30340;PRIVATE&#26159;&#21333;&#32842;</span><br></pre></td></tr></table></figure>
<ul>
<li>targetId：聊天目标用户id</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.targerId = &#34;&#34;</span><br></pre></td></tr></table></figure>
<ul>
<li>userName:聊天目标用户的昵称</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.userName = &#34;&#34;</span><br></pre></td></tr></table></figure>
<ul>
<li>title:聊天界面显示的标题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.title = self.userName</span><br></pre></td></tr></table></figure>
<p>RCConversationViewController中还有其他很多的属性可以自定义，比如用户头像形状之类的，这些可以在它的头文件中找到。</p>
<h3 id="测试单聊">测试单聊</h3><p>设置好以上内容之后，单聊的工作就已经做好了，现在我们可以测试单聊的效果，这里由于还没有其他的用户，我们就先和自己聊天来测试一下单聊的效果；<br>把targerId设置成已经登录的id，然后就可以自己和自己聊天了，内部集成的界面还是挺简洁易用的，虽然是自己和自己聊天，但是他也不是在本地操作的，也要经过融云的服务器，所以你把网络断开的情况下是不能发出信息的。<br>到这里单聊已经实现了，但是你会发现聊天界面他是不会显示用户头像的，虽然你在初始化的时候给了一个头像的url，但是他是不会加载出来的，不得不说这一点确实很脑残，主要原因是融云为了安全起见，他的服务器是不会储存用户信息的，在融云那边只有一个Token和userid的对应关系，和你发送给他的好友关系，也就是说你的用户信息需要自己在用一个服务器存起来，然后向融云提供一个用户信息提供者；</p>
<h3 id="设置用户信息提供者">设置用户信息提供者</h3><p>要设置用户信息提供者首先要实现RCIMUserInfoDataSource协议，所以我们要在APP启动的时候让Appdelegate实现协议，然后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func getUserInfoWithUserId(userId: String!, completion: ((RCUserInfo!) -&#62; Void)!) &#123;&#10;        let userInfo = RCUserInfo()&#10;        userInfo.userId = userId&#10;        switch userId&#123;&#10;        case &#34;xinnyu&#34;:&#10;            userInfo.name = &#34;&#28504;&#26032;&#23431;&#34;&#10;            userInfo.portraitUri = &#34;http://7xl9qm.com1.z0.glb.clouddn.com/avatar.png&#34;&#10;        case &#34;liuchuqi&#34;:&#10;            userInfo.name = &#34;A&#34;&#10;            userInfo.portraitUri = &#34;http://www4.qqjay.com/u/files/2011/1216/d3302821f418fc5539398cb3ba72cd8c.jpg&#34;&#10;        case &#34;lijie&#34;:&#10;            userInfo.name = &#34;B&#34;&#10;            userInfo.portraitUri = &#34;http://image.photophoto.cn/nm-6/018/030/0180300244.jpg&#34;&#10;        case &#34;tansanxiang&#34;:&#10;            userInfo.name = &#34;C&#34;&#10;            userInfo.portraitUri = &#34;http://cdn.duitang.com/uploads/item/201407/26/20140726221707_i4ZnL.thumb.224_0.jpeg&#34;&#10;        default:&#10;            print(&#34;&#27809;&#26377;&#36825;&#20010;&#29992;&#25143;&#34;)&#10;        &#125;&#10;        &#10;        completion(userInfo)&#10;    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.rongcloud.cn/" target="_blank" rel="external">融云</a> 是国内一家专门为APP开发者提供IM服务的公司，利用它提供的SDK可以快速使你的APP集成IM通讯能力。<br>详细的使用方法在]]>
    </summary>
    
      <category term="Swift" scheme="http://xinnyu.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://xinnyu.com/tags/iOS/"/>
    
      <category term="iOS" scheme="http://xinnyu.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用AVPlayer 播放在线音频,并实现后台锁屏播放，自动连播]]></title>
    <link href="http://xinnyu.com/2015/09/21/%E4%BD%BF%E7%94%A8AVPlayer-%E6%92%AD%E6%94%BE%E5%9C%A8%E7%BA%BF%E9%9F%B3%E9%A2%91/"/>
    <id>http://xinnyu.com/2015/09/21/使用AVPlayer-播放在线音频/</id>
    <published>2015-09-20T16:17:37.000Z</published>
    <updated>2015-09-20T17:50:11.000Z</updated>
    <content type="html"><![CDATA[<p>在iOS开发中，AVAudioPlayer不是不能播放在线音频的，要播放在线音频只能用以下几个方法：</p>
<ul>
<li>AVPlayer </li>
<li>MPMoviePlayerController 能实现音乐流播（但是此方法苹果在iOS9中已经不推荐使用了）</li>
<li>Audioqueue，Audiostream （太复杂）</li>
<li>第三方库AudioStreamer（只能播放在线音频）</li>
</ul>
<p>所以用AVPlayer来实现在线音频播放是最好的选择；一下就是利用AVPlayer实现音乐流播并实现后台锁屏播放和设置自动连播的大概步骤：</p>
<p>项目源代码：<a href="https://github.com/xinnyu/DouBanFM" target="_blank" rel="external">Swift 2.0 版豆瓣电台</a></p>
<h3 id="初始化">初始化</h3><p>先声明AVplayer和AVPlayerItem的实例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var musicPlayer:AVPlayer!&#10;var playerItem:AVPlayerItem?</span><br></pre></td></tr></table></figure></p>
<p>然后在需要的播放音频的地方给它赋值：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.musicPlayer = AVPlayer()&#10;let playerLayer = AVPlayerLayer(player: self.musicPlayer)&#10;self.view.layer.addSublayer(playerLayer)&#10;      &#10;let url = NSURL(string: &#34;   &#34;)&#10;   &#10;//&#26367;&#25442;&#24403;&#21069;&#30340;playerItem&#10;self.musicPlayer.replaceCurrentItemWithPlayerItem(playerItem)&#10;//&#24320;&#22987;&#25773;&#25918;&#10;self.musicPlayer.play()</span><br></pre></td></tr></table></figure></p>
<p>以上就是实现播放在线音频的代码，但是如果要实现后台播放和自动连播的话，还要做以下工作：</p>
<h3 id="自动连播">自动连播</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//&#24403;&#25773;&#25918;&#23436;&#25104;&#20102;&#20043;&#21518;&#21457;&#36865;&#36890;&#30693;&#65292;&#32487;&#32493;&#25773;&#25918;&#10;NSNotificationCenter.defaultCenter().addObserver(self, selector: &#34;playerItemDidReachEnd:&#34;, name: AVPlayerItemDidPlayToEndTimeNotification, object: playerItem)&#10; &#10;//&#27809;&#26377;&#25773;&#25918;&#23436;&#25104;&#30340;&#36890;&#30693;       &#10;NSNotificationCenter.defaultCenter().addObserver(self, selector: &#34;playerItemDidNotReachEnd&#34;, name: AVPlayerItemFailedToPlayToEndTimeNotification, object: playerItem)&#10;&#10;//&#25509;&#21463;&#21040;&#36890;&#30693;&#21518;&#21709;&#24212;&#30340;&#26041;&#27861;&#10;func playerItemDidReachEnd(aNotification:NSNotification)&#123;&#10;&#9;//&#33258;&#21160;&#25773;&#25918;&#30456;&#20851;&#10;&#10;&#10;&#125;&#10;&#10;func playerItemDidNotReachEnd(aNotification:NSNotification)&#123;&#10;&#9;//&#27468;&#26354;&#27809;&#26377;&#27491;&#24120;&#25773;&#25918;&#21040;&#32467;&#26463;&#10;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><em>后台播放</em></p>
<p>如果是播放本地音频的话，后台播放只要在APP启动时加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let session = AVAudioSession.sharedInstance()&#10;try! session.setCategory(AVAudioSessionCategoryPlayback)&#10;try! session.setActive(true)</span><br></pre></td></tr></table></figure>
<p>然后在info.plist文件中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#60;key&#62;UIBackgroundModes&#60;/key&#62;&#10;&#60;array&#62;&#10;&#60;string&#62;audio&#60;/string&#62;&#10;&#60;/array&#62;</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<p>但是如果每一首歌都要请求网络的话，只做上述工作时行不通的，还要在实例化AVPlayer的地方加上：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//&#21518;&#21488;&#25773;&#25918;&#10;var bgTask:UIBackgroundTaskIdentifier = 0&#10;if UIApplication.sharedApplication().applicationState == UIApplicationState.Background &#123;&#10;&#9;self.musicPlayer.play()&#10;&#9;netMusicIsPlaying = true&#10;            &#10;&#9;let app:UIApplication = UIApplication.sharedApplication()&#10;&#9;let newTask:UIBackgroundTaskIdentifier = app.beginBackgroundTaskWithExpirationHandler(nil)&#10;if newTask != UIBackgroundTaskInvalid &#123;&#10;&#9;app.endBackgroundTask(bgTask)&#10;&#9;&#125;&#10;&#9;bgTask = newTask&#10;&#125;else&#123;&#10;&#9;self.musicPlayer.play()&#10;&#9;netMusicIsPlaying = true&#10;&#9;isPlayOffline = false&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样才能实现真正的后台播放。</p>
<h3 id="锁屏界面和控制中心添加详情">锁屏界面和控制中心添加详情</h3><p>首先要作以下准备工作</p>
<ul>
<li>在applicationDidEnterBackground中添加：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">application.beginReceivingRemoteControlEvents()</span><br></pre></td></tr></table></figure>
<ul>
<li>在ViewDidAppear中添加：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIApplication.sharedApplication().beginReceivingRemoteControlEvents()&#10;self.becomeFirstResponder()</span><br></pre></td></tr></table></figure>
<ul>
<li>在viewDidDisappear中添加：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIApplication.sharedApplication().endReceivingRemoteControlEvents()&#10;self.resignFirstResponder()</span><br></pre></td></tr></table></figure>
<ul>
<li>重写canBecomeFirstResponder方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override func canBecomeFirstResponder() -&#62; Bool &#123;&#10;&#9;return true&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>然后把歌曲详情设置到锁屏界面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#10;func configNowPlayingInfoCenter()&#123;&#10;&#9;if (NSClassFromString(&#34;MPNowPlayingInfoCenter&#34;) != nil) &#123;&#10;&#9;    //&#38145;&#23631;&#30028;&#38754;&#22270;&#29255;&#30340;&#23384;&#20648;&#26041;&#24335;          &#10;&#9;&#9;let mArt:MPMediaItemArtwork = MPMediaItemArtwork(image: currentSongPic)&#10;&#9;&#9;//&#38145;&#23631;&#30028;&#38754;&#20449;&#24687;&#23383;&#20856;&#10;&#9;&#9;var dic:[String : AnyObject] = [ &#10;&#9;&#9;&#9;MPMediaItemPropertyTitle : currentSongTitle,&#10;&#9;&#9;&#9;MPMediaItemPropertyArtist : currentSongArtist,&#10;&#9;&#9;&#9;MPMediaItemPropertyArtwork : mArt &#10;&#9;&#9;]&#10;     &#10;&#9;&#9;//&#33719;&#21462;&#24403;&#21069;&#25773;&#25918;&#30340;&#26102;&#38388;&#21644;&#27468;&#26354;&#24635;&#26102;&#38271;    &#10;&#9;&#9;let time = self.musicPlayer.currentTime()&#10;&#9;&#9;let duration = self.musicPlayer.currentItem!.asset.duration&#10;&#10;&#9;&#9;//&#25226;&#20449;&#24687;&#20256;&#36882;&#32473;&#38145;&#23631;&#30028;&#38754;&#10;&#9;&#9;dic.updateValue(NSNumber(double: CMTimeGetSeconds(time)), forKey: MPNowPlayingInfoPropertyElapsedPlaybackTime )&#10;&#9;&#9;dic.updateValue(NSNumber(double: CMTimeGetSeconds(duration)), forKey: MPMediaItemPropertyPlaybackDuration)&#10;&#9;&#9;dic.updateValue(NSNumber(float: 1.0), forKey: MPNowPlayingInfoPropertyPlaybackRate)&#10;&#10;&#9;&#9;MPNowPlayingInfoCenter.defaultCenter().nowPlayingInfo = dic&#10;&#9;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>再处理锁屏和控制中心点击事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override func remoteControlReceivedWithEvent(event: UIEvent?) &#123;&#10;&#9;if event!.type == UIEventType.RemoteControl &#123;&#10;&#9;&#9;if event!.subtype == UIEventSubtype.RemoteControlNextTrack &#123;&#10;&#9;&#9;&#9;//&#19979;&#19968;&#26354;&#10;&#10;&#9;&#9;&#125;else if event!.subtype == UIEventSubtype.RemoteControlPause&#123;&#10;&#9;&#9;&#9;//&#26242;&#20572;&#25353;&#38062;&#10;&#10;&#9;&#9;&#125;else if event!.subtype == UIEventSubtype.RemoteControlPlay&#123;&#10;&#9;&#9;&#9;//&#25773;&#25918;&#25353;&#38062;&#10;&#10;&#9;&#9;&#125;&#10;&#9;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用KVO监视播放器的缓存状态和播放状态">利用KVO监视播放器的缓存状态和播放状态</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//&#20808;&#31227;&#38500;&#35266;&#23519;&#32773;      &#10;if self.musicPlayer.currentItem != nil &#123;&#10;&#9;self.musicPlayer.currentItem?.removeObserver(self, forKeyPath: &#34;status&#34;)&#10;&#9;self.musicPlayer.currentItem?.removeObserver(self, forKeyPath: &#34;loadedTimeRanges&#34;)&#10;&#125;&#10;&#10;//&#28155;&#21152;&#35266;&#23519;&#32773;&#10;playerItem.addObserver(self, forKeyPath: &#34;status&#34;, options: .New, context: nil)&#10;playerItem.addObserver(self, forKeyPath: &#34;loadedTimeRanges&#34;, options: .New, context: nil)&#10;&#10;//&#25773;&#25918;&#29366;&#24577;&#10;playerItem.addObserver(self, forKeyPath: &#34;status&#34;, options: .New, context: nil)&#10;//&#32531;&#23384;&#36827;&#24230;&#10;playerItem.addObserver(self, forKeyPath: &#34;loadedTimeRanges&#34;, options: .New, context: nil)&#10;&#10;//&#23646;&#24615;&#25913;&#21464;&#20102;&#35201;&#23454;&#29616;&#30340;&#26041;&#27861;&#10;override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&#60;Void&#62;) &#123;&#10;&#9;//&#33719;&#21462;&#32531;&#23384;&#36827;&#24230;&#10;&#9;if keyPath == &#34;loadedTimeRanges&#34; &#123;&#10;&#9;let array = (object as! AVPlayerItem).loadedTimeRanges&#10;    if let range = array.first &#123;&#10;&#9;&#9;&#9;//&#24403;&#21069;&#32531;&#23384;&#30340;&#24635;&#26102;&#38388;&#10;       let rangeValue = range.CMTimeRangeValue&#10;       let duration = rangeValue.duration&#10;&#9;&#9;&#9;//&#24635;&#26102;&#38388;&#25442;&#31639;&#25104;&#31186;&#25968;&#10;       let loadTime = CMTimeGetSeconds(duration)&#10;&#10;&#9;&#125;else&#123;&#10;&#9;//&#33719;&#21462;&#24403;&#21069;&#25773;&#25918;&#29366;&#24577;&#10;&#10;&#9;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><em>获取到了缓存时间可以判断当前的缓存时间和当前播放时间的值，来判断网络状况，同时也可以在做视频播放器时用来作缓存条</em>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在iOS开发中，AVAudioPlayer不是不能播放在线音频的，要播放在线音频只能用以下几个方法：</p>
<ul>
<li>AVPlayer </li>
<li>MPMoviePlayerController 能实现音乐流播（但是此方法苹果在iOS9中已经不推荐使用了）]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 常用第三方库7(Reachability)]]></title>
    <link href="http://xinnyu.com/2015/09/21/iOS-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%937-Reachability/"/>
    <id>http://xinnyu.com/2015/09/21/iOS-常用第三方库7-Reachability/</id>
    <published>2015-09-20T16:06:47.000Z</published>
    <updated>2015-09-26T17:15:40.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/tonymillion/Reachability" target="_blank" rel="external">Reachability</a> 是一个检测网络状态的框架。<br>开发Web等网络应用程序的时候，需要确认网络环境，连接情况等信息。如果没有处理这些信息的话，是不会通过Apple的审查的。</p>
<h3 id="使用方法：">使用方法：</h3><p>将Reachability.h 和 Reachability.m 拷贝到你的工程中。</p>
<p>然后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var reach:Reachability?&#10;&#10;func checkNetStatus()&#123;&#10;       self.reach = Reachability.reachabilityForInternetConnection()&#10;       // Tell the reachability that we DON&#39;T want to be reachable on 3G/EDGE/CDMA&#10;       self.reach!.reachableOnWWAN = false&#10;       &#10;       if reach?.currentReachabilityStatus() == NetworkStatus.ReachableViaWWAN &#123;&#10;           self.net = NetState.Mobile&#10;       &#125;&#10;       &#10;       // Here we set up a NSNotification observer. The Reachability that caused the notification&#10;       // is passed in the object parameter&#10;       NSNotificationCenter.defaultCenter().addObserver(self,&#10;           selector: &#34;reachabilityChanged:&#34;,&#10;           name: kReachabilityChangedNotification,&#10;           object: nil)&#10;       &#10;       self.reach!.startNotifier()&#10;   &#125;&#10;   &#10;   func reachabilityChanged(notification: NSNotification)&#123;&#10;       &#10;       if self.reach!.isReachableViaWiFi()  &#123;&#10;           print(&#34;&#33021;&#35775;&#38382;&#32593;&#32476;&#34;)&#10;           &#10;           &#10;       &#125;else if  self.reach!.isReachableViaWWAN()&#123;&#10;           appDelegate.isCanUseNetWork = true&#10;           print(&#34;&#27491;&#22312;&#20351;&#29992;&#31227;&#21160;&#32593;&#32476;&#34;)&#10;           &#10;       &#125;else &#123;&#10;           &#10;           print(&#34;&#27809;&#26377;&#32593;&#32476;!!!&#34;) &#10;           self.net = NetState.None&#10;       &#125;&#10;   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/tonymillion/Reachability" target="_blank" rel="external">Reachability</a> 是一个检测网络状态的框架。<br>开发Web等网络应用程序的时候，需要]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 常用第三方库7(SDWebImage)]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%937-SDWebImage/"/>
    <id>http://xinnyu.com/2015/09/20/iOS-常用第三方库7-SDWebImage/</id>
    <published>2015-09-20T15:45:43.000Z</published>
    <updated>2015-09-20T16:04:18.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a>是一个著名的第三方库，它的作用是：</p>
<blockquote>
<p>Asynchronous image downloader with cache support with an UIImageView category.<br>就是一个异步加载图片并且支持缓存的UIImage分类；</p>
</blockquote>
<h3 id="使用方法：">使用方法：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imageView.sd_setImageWithURL(NSURL(string: &#34;&#34;), placeholderImage: UIImage(named: &#34;placeholder&#34;))</span><br></pre></td></tr></table></figure>
<p>清除缓存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SDImageCache.sharedImageCache().cleanDisk()&#10;SDImageCache.sharedImageCache().clearMemory()</span><br></pre></td></tr></table></figure>
<p>这个框架使用简单，然而而其中复杂的实现细节全部隐藏在这行代码之后；这边有一篇它的源代码分析：<a href="">http://draveness.me/ios-yuan-dai-ma-jie-xi-sdwebimage/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a>是一个著名的第三方库，它的作用是：</p>
<blockquote>
<p>Asynchronou]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 常用第三方库6(POP动画)]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%936-POP%E5%8A%A8%E7%94%BB/"/>
    <id>http://xinnyu.com/2015/09/20/iOS-常用第三方库6-POP动画/</id>
    <published>2015-09-20T14:53:46.000Z</published>
    <updated>2015-09-26T14:40:41.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/facebook/pop" target="_blank" rel="external">POP</a>是Facebook公司的一个开源项目，它是一个完全不同于Core Animation的动画引擎；它在基本的静态动画的基础上增加的弹簧动画与衰减动画 使之能创造出更真实更具物理性的交互动画 POP的API可以快速的与现有的ObjC代码集成并可以作用于任意对象的任意属性，POP是个相当成熟且久经考验的框架，Facebook出品的令人惊叹的Paper应用中的所有动画和效果即出自POP。</p>
<h3 id="使用方式：">使用方式：</h3><p>POP默认支持三种动画 但同时也支持自定义动画</p>
<ul>
<li>POPBasicAnimation</li>
<li>POPSpringAnimation</li>
<li>POPDecayAnimation</li>
<li>POPCustomAnimation //自定义动画</li>
</ul>
<p>这里我们只讨论前三种，因为自定义动画还没用过；</p>
<h4 id="代码示例：">代码示例：</h4><p><strong>BasicAnimation</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let rotation = POPBasicAnimation(propertyNamed: kPOPLayerRotation[^POP&#21160;&#30011;&#30340;&#21442;&#25968;])&#10;rotation.toValue = M_PI * 2&#10;rotation.duration = 10&#10;rotation.repeatForever = true&#10;rotation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionLinear)&#10;        &#10;self.layer.pop_addAnimation(rotation, forKey: &#34;&#26059;&#36716;&#34;)</span><br></pre></td></tr></table></figure></p>
<p>POPBasicAnimation提供四种时间曲线,这个和Core Animation中的是一样的：</p>
<ul>
<li>kCAMediaTimingFunctionLinear</li>
<li>kCAMediaTimingFunctionEaseIn</li>
<li>kCAMediaTimingFunctionEaseOut</li>
<li>kCAMediaTimingFunctionEaseInEaseOut</li>
</ul>
<p><strong>POPSpringAnimation</strong><br>弹性动画</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//&#23454;&#20363;&#21270;POP&#10;let scale = POPSpringAnimation(propertyNamed:kPOPViewScaleXY)&#10;//&#35774;&#32622;&#32467;&#26463;&#20540;&#10;scale.toValue = NSValue(CGPointMake(2,2))&#10;//&#25391;&#24133;&#65292;&#33539;&#22260;0-20&#10;scale.springBounciness = 20&#10;//&#25391;&#21160;&#36895;&#24230;,&#33539;&#22260;0-20&#10;scale.springSpeed = 1&#10;view.layer.pop_addAnimatiom(scale,foKey:&#34;scale&#34;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>弹性动画可配置的属性有：</p>
<ul>
<li>springBounciness:4.0    //[0-20] 弹力 越大则震动幅度越大</li>
<li>springSpeed     :12.0   //[0-20] 速度 越大则动画结束越快</li>
<li>dynamicsTension :0      //拉力  下面这三个都跟物理力学模拟相关 数值调整起来很费时，建议就用默认值</li>
<li>dynamicsFriction:0      //摩擦 同上</li>
<li>dynamicsMass    :0      //质量 同上</li>
</ul>
</blockquote>
<p><strong>POPDecayAnimation</strong><br>阻尼动画</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POPDecayAnimation *anDecay = [POPDecayAnimation animationWithPropertyNamed:kPOPLayerPositionX];&#10;anDecay.velocity = @(600);&#10;anDecay.beginTime = CACurrentMediaTime() + 1.0f;&#10;[self.square pop_addAnimation:anDecay forKey:@&#34;position&#34;];</span><br></pre></td></tr></table></figure>
<p><em>注意:这里对POPDecayAnimation设置toValue是没有意义的 会被忽略(因为目的状态是动态计算得到的</em>)</p>
<blockquote>
<p>POPDecayAnimation可配置的属性与默认值有:<br>deceleration:0.998  //衰减系数(越小则衰减得越快)</p>
</blockquote>
<p><em>注意:POPDecayAnimation也是没有duration字段的 其动画持续时间由velocity与deceleration决定</em></p>
<p>POP默认支持的动画属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**&#10; Common CALayer property names.&#10; */&#10;extern NSString * const kPOPLayerBackgroundColor;&#10;extern NSString * const kPOPLayerBounds;&#10;extern NSString * const kPOPLayerCornerRadius;&#10;extern NSString * const kPOPLayerBorderWidth;&#10;extern NSString * const kPOPLayerBorderColor;&#10;extern NSString * const kPOPLayerOpacity;&#10;extern NSString * const kPOPLayerPosition;&#10;extern NSString * const kPOPLayerPositionX;&#10;extern NSString * const kPOPLayerPositionY;&#10;extern NSString * const kPOPLayerRotation;&#10;extern NSString * const kPOPLayerRotationX;&#10;extern NSString * const kPOPLayerRotationY;&#10;extern NSString * const kPOPLayerScaleX;&#10;extern NSString * const kPOPLayerScaleXY;&#10;extern NSString * const kPOPLayerScaleY;&#10;extern NSString * const kPOPLayerSize;&#10;extern NSString * const kPOPLayerSubscaleXY;&#10;extern NSString * const kPOPLayerSubtranslationX;&#10;extern NSString * const kPOPLayerSubtranslationXY;&#10;extern NSString * const kPOPLayerSubtranslationY;&#10;extern NSString * const kPOPLayerSubtranslationZ;&#10;extern NSString * const kPOPLayerTranslationX;&#10;extern NSString * const kPOPLayerTranslationXY;&#10;extern NSString * const kPOPLayerTranslationY;&#10;extern NSString * const kPOPLayerTranslationZ;&#10;extern NSString * const kPOPLayerZPosition;&#10;extern NSString * const kPOPLayerShadowColor;&#10;extern NSString * const kPOPLayerShadowOffset;&#10;extern NSString * const kPOPLayerShadowOpacity;&#10;extern NSString * const kPOPLayerShadowRadius;&#10;&#10;/**&#10; Common CAShapeLayer property names.&#10; */&#10;extern NSString * const kPOPShapeLayerStrokeStart;&#10;extern NSString * const kPOPShapeLayerStrokeEnd;&#10;extern NSString * const kPOPShapeLayerStrokeColor;&#10;extern NSString * const kPOPShapeLayerFillColor;&#10;&#10;/**&#10; Common NSLayoutConstraint property names.&#10; */&#10;extern NSString * const kPOPLayoutConstraintConstant;&#10;&#10;&#10;#if TARGET_OS_IPHONE&#10;&#10;/**&#10; Common UIView property names.&#10; */&#10;extern NSString * const kPOPViewAlpha;&#10;extern NSString * const kPOPViewBackgroundColor;&#10;extern NSString * const kPOPViewBounds;&#10;extern NSString * const kPOPViewCenter;&#10;extern NSString * const kPOPViewFrame;&#10;extern NSString * const kPOPViewScaleX;&#10;extern NSString * const kPOPViewScaleXY;&#10;extern NSString * const kPOPViewScaleY;&#10;extern NSString * const kPOPViewSize;&#10;extern NSString * const kPOPViewTintColor;&#10;&#10;/**&#10; Common UIScrollView property names.&#10; */&#10;extern NSString * const kPOPScrollViewContentOffset;&#10;extern NSString * const kPOPScrollViewContentSize;&#10;extern NSString * const kPOPScrollViewZoomScale;&#10;extern NSString * const kPOPScrollViewContentInset;&#10;&#10;/**&#10; Common UITableView property names.&#10; */&#10;extern NSString * const kPOPTableViewContentOffset;&#10;extern NSString * const kPOPTableViewContentSize;&#10;&#10;/**&#10; Common UICollectionView property names.&#10; */&#10;extern NSString * const kPOPCollectionViewContentOffset;&#10;extern NSString * const kPOPCollectionViewContentSize;&#10;&#10;/**&#10; Common UINavigationBar property names.&#10; */&#10;extern NSString * const kPOPNavigationBarBarTintColor;&#10;&#10;/**&#10; Common UIToolbar property names.&#10; */&#10;extern NSString * const kPOPToolbarBarTintColor;&#10;&#10;/**&#10; Common UITabBar property names.&#10; */&#10;extern NSString * const kPOPTabBarBarTintColor;&#10;&#10;/**&#10; Common UILabel property names.&#10; */&#10;extern NSString * const kPOPLabelTextColor;</span><br></pre></td></tr></table></figure>
<h4 id="自定义属性：">自定义属性：</h4><p>POP默认支持的三种动画都继承自POPPropertyAnimation POPPropertyAnimation中定义了一个叫property的属性( 之前没有用到它是因为POP根据不同的默认动画属性帮你生成了默认的property) 而这个property则是用来驱动POP的动画效果中的重要一环。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POPAnimatableProperty *prop = [POPAnimatableProperty propertyWithName:@&#34;prop&#34; initializer:^(POPMutableAnimatableProperty *prop) &#123;&#10;    // read value&#10;    prop.readBlock = ^(id obj, CGFloat values[]) &#123;&#10;        &#10;    &#125;;&#10;    // write value&#10;    prop.writeBlock = ^(id obj, const CGFloat values[]) &#123;&#10;&#10;    &#125;;&#10;    // dynamics threshold&#10;    prop.threshold = 0.01;&#10;&#125;];</span><br></pre></td></tr></table></figure>
<p>其组成就是一个readBlock一个writeBlock和一个threashold</p>
<ul>
<li>readBlock告诉POP当前的属性值</li>
<li>writeBlock中修改变化后的属性值</li>
<li>threashold决定了动画变化间隔的阈值 值越大writeBlock的调用次数越少</li>
<li>POPAnimatableProperty其实是POP中一个比较重要的东西,像上面提到的POP自带的动画属性 查看源代码可以看到也只是POP自动帮你设置好了POPAnimatableProperty而已,其作用就是当动画的某个时间片被触发时,告诉系统如何根据当前时间片做出变化.</li>
</ul>
<p>下面是一个秒表动画，是利用自定义属性的POP做出来的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POPAnimatableProperty *prop = [POPAnimatableProperty propertyWithName:@&#34;countdown&#34; initializer:^(POPMutableAnimatableProperty *prop) &#123;&#10;        &#10;        prop.writeBlock = ^(id obj, const CGFloat values[]) &#123;&#10;            UILabel *lable = (UILabel*)obj;&#10;            label.text = [NSString stringWithFormat:@&#34;%02d:%02d:%02d&#34;,(int)values[0]/60,(int)values[0]%60,(int)(values[0]*100)%100];&#10;        &#125;;&#10;        &#10;//        prop.threshold = 0.01f;&#10;    &#125;];&#10;    &#10;    POPBasicAnimation *anBasic = [POPBasicAnimation linearAnimation];   //&#31186;&#34920;&#24403;&#28982;&#24517;&#39035;&#26159;&#32447;&#24615;&#30340;&#26102;&#38388;&#20989;&#25968;&#10;    anBasic.property = prop;    //&#33258;&#23450;&#20041;&#23646;&#24615;&#10;    anBasic.fromValue = @(0);   //&#20174;0&#24320;&#22987;&#10;    anBasic.toValue = @(3*60);  //180&#31186;&#10;    anBasic.duration = 3*60;    //&#25345;&#32493;3&#20998;&#38047;&#10;    anBasic.beginTime = CACurrentMediaTime() + 1.0f;    //&#24310;&#36831;1&#31186;&#24320;&#22987;&#10;    [label pop_addAnimation:anBasic forKey:@&#34;countdown&#34;];</span><br></pre></td></tr></table></figure>
<p>出处：<a href="http://adad184.com/2015/03/11/intro-to-pop/" target="_blank" rel="external">http://adad184.com/2015/03/11/intro-to-pop/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/facebook/pop" target="_blank" rel="external">POP</a>是Facebook公司的一个开源项目，它是一个完全不同于Core Animation的动画引擎；它在基本的静态动画]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 常用第三方库5(PNChart)]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%935-PNChart/"/>
    <id>http://xinnyu.com/2015/09/20/iOS-常用第三方库5-PNChart/</id>
    <published>2015-09-20T14:24:43.000Z</published>
    <updated>2015-09-26T15:26:34.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="external">PNChart</a> 是一个简约，易用的第三方图表库，它支持折线图，柱形图，饼状图和圆形图的绘制；</p>
<h3 id="使用方法">使用方法</h3><ul>
<li>画折线图</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func&#160; setLineChart()&#123;&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#160; /// &#23450;&#20041;&#19968;&#20010;lineChart &#160; &#160;&#10;&#9;var lineChart = PNLineChart(frame: CGRectMake(0, self.view.frame.height/4, self.view.frame.width, self.view.frame.height/2))&#10;&#9;//&#19981;&#35201;&#20351;&#29992;&#19979;&#38754;&#30340;&#26041;&#27861;&#65292;Width &#19981;&#22909;&#35745;&#31639;&#65292;&#21482;&#35774;&#32622;&#25968;&#25454;&#30340;&#35805;&#23485;&#24230;&#20250;&#33258;&#21160;&#35774;&#23450;&#10;&#9;//lineChart.setXLabels([&#34;A&#34;,&#34;B&#34;,&#34;C&#34;,&#34;D&#34;,&#34;E&#34;,&#34;F&#34;], withWidth: 50)&#10;&#9;lineChart.xLabels = [&#34;A&#34;,&#34;B&#34;,&#34;C&#34;,&#34;D&#34;,&#34;E&#34;,&#34;F&#34;]&#10;&#9;lineChart.axisColor = UIColor.blackColor()&#10;&#9;lineChart.showCoordinateAxis = true&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#9;/// &#35774;&#32622;&#31532;&#19968;&#26681;&#25240;&#32447;&#10;&#9;var dataArray = [1,4,9,20,8,9]&#10;&#9;var lineChartData = PNLineChartData()&#10;&#9;//lineChartData.lineWidth = 20&#10;&#9;lineChartData.itemCount = UInt(dataArray.count)&#10;&#9;lineChartData.color = UIColor.greenColor()&#10;&#9;lineChartData.getData = (&#123;(index:UInt) -&#62; PNLineChartDataItem in&#10;&#9;var y = dataArray[Int(index)]&#10;&#9;return PNLineChartDataItem(y: CGFloat(y))&#10;&#9;&#125;)&#10;&#10;&#9;//&#20026;&#25968;&#25454;&#28304;&#35774;&#32622;Title&#10;&#9;lineChartData.dataTitle = &#34;Swift&#34;&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#9;/// &#35774;&#32622;&#31532;&#20108;&#26681;&#25240;&#32447;&#10;&#9;var dataArray2 = [5,19,9,3,5]&#10;&#9;var lineChartData2 = PNLineChartData()&#10;&#9;//lineChartData.lineWidth = 20&#10;&#9;lineChartData2.itemCount = UInt(dataArray2.count)&#10;&#9;lineChartData2.color = UIColor.redColor()&#10;&#9;lineChartData2.getData = (&#123;(index:UInt) -&#62; PNLineChartDataItem in&#10;&#9;&#9;var y = dataArray2[Int(index)]&#10;&#9;&#9;return PNLineChartDataItem(y: CGFloat(y))&#10;&#9;&#125;)&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#9;//&#25226;&#25240;&#32447;&#21152;&#20837;&#21040;lineChart&#20013;&#65292;&#24320;&#22987;&#30011;&#22270;&#10;&#9;lineChart.chartData = [lineChartData,lineChartData2]&#10;&#9;lineChart.strokeChart()&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#9;self.view.addSubview(lineChart)&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#9;/// &#20026;&#22270;&#34920;&#35774;&#32622;&#26631;&#31614;&#65292;****&#35201;&#22312;&#30011;&#22270;&#20043;&#21518;&#28155;&#21152;****&#10;&#9;//&#20026;&#25968;&#25454;&#28304;2&#35774;&#32622;Title&#10;&#9;lineChartData2.dataTitle = &#34;OC&#34;&#10;&#9;//&#36873;&#25321;&#26631;&#31614;&#39118;&#26684;&#10;&#9;lineChart.legendStyle = PNLegendItemStyle.Serial&#10;&#9;//&#33719;&#21462;&#26631;&#31614;&#10;&#9;var legend = lineChart.getLegendWithMaxWidth(self.view.frame.width)&#10;&#9;//&#35774;&#32622;&#26631;&#31614;&#20301;&#32622;&#10;&#9;legend.frame = CGRectMake(50, lineChart.frame.origin.y + lineChart.frame.height + 10 , legend.frame.width, legend.frame.height)&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#9;self.view.addSubview(legend)&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#9;lineChart.delegate = self&#10;&#9;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>画柱形图：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func setBarChart()&#123;&#10;&#9;//&#30452;&#25509;&#21021;&#22987;&#21270;&#19968;&#20010;PNBarChart&#65292;&#19981;&#35201;&#25968;&#25454;&#28304;&#10;&#9;var barChart = PNBarChart(frame: CGRectMake(0, 200, self.view.frame.width, 350))&#10;&#9;barChart.xLabels = [&#34;A&#34;,&#34;B&#34;,&#34;C&#34;,&#34;D&#34;,&#34;E&#34;]&#10;&#9;//barChart.xLabelWidth = 55&#10;&#9;barChart.yValues = [1,3,6,-7,15]&#10;&#9;//&#26174;&#31034;&#22270;&#34920;&#36793;&#30028;&#10;&#9;barChart.showChartBorder = true&#10;&#9;//&#20801;&#35768;&#36127;&#25968;&#10;&#9;barChart.showLevelLine = false&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#9;//barChart.strokeColor = UIColor.redColor()&#10;&#9;barChart.barRadius = 2&#10;&#9;//&#35774;&#32622;&#25991;&#23383;&#39068;&#33394;&#65292;**********&#35774;&#32622;&#19981;&#20102;************&#10;&#9;barChart.labelTextColor = UIColor.redColor()&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#9;//&#24320;&#22987;&#30011;&#22270;&#10;&#9;barChart.strokeChart()&#10;&#9;self.view.add&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>画圆形图：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func setCircleChart()&#123;&#10;&#9;//&#30452;&#25509;&#21021;&#22987;&#21270;&#19968;&#20010;PNCircleChart &#65292;&#19981;&#35201;&#25968;&#25454;&#28304;&#20043;&#31867;&#30340;&#10;&#9;var circelChart = PNCircleChart(frame: CGRectMake(self.view.frame.width/2 - self.view.frame.width/4, 200, self.view.frame.width/2, 200), total: 100, current: 60, clockwise: false, shadow: true, shadowColor: UIColor.grayColor())&#10;&#9;circelChart.current = 60&#10;&#9;circelChart.total = 100&#10;&#9;//circelChart.strokeColor = UIColor.greenColor()&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#9;circelChart.strokeChart()&#10;&#9;self.view.addSubview(circelChart)&#10;&#9;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>画饼状图：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func setPieChart()&#123;&#10;&#9;//&#20808;&#23450;&#20041;&#19968;&#20010;PNPieChartDataItem&#25968;&#32452;&#65292;116 202 33&#160; &#160; &#160; 72 114 224&#10;&#9;var items = [PNPieChartDataItem(value: 50, color: UIColor(red: 116/255, green: 202/255, blue: 33/255, alpha: 1) , description: &#34;Swift&#34;),PNPieChartDataItem(value: 20, color: UIColor(red: 72/255, green: 114/255, blue: 224/255, alpha: 1) , description: &#34;OC&#34;)]&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#9;var pieChart = PNPieChart(frame: CGRectMake(self.view.frame.width/2 - self.view.frame.width/3, 200, self.view.frame.width/1.5, 200), items: items)&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#9;pieChart.descriptionTextFont = UIFont.systemFontOfSize(15)&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#9;pieChart.strokeChart()&#10;&#9;self.view.addSubview(pieChart)&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#9;//&#36873;&#25321;&#26631;&#31614;&#39118;&#26684;&#10;&#9;pieChart.legendStyle = PNLegendItemStyle.Serial&#10;&#9;//&#33719;&#21462;&#26631;&#31614;&#10;&#9;var legend = pieChart.getLegendWithMaxWidth(self.view.frame.width)&#10;&#9;//&#35774;&#32622;&#26631;&#31614;&#20301;&#32622;&#10;&#9;legend.frame = CGRectMake(50, pieChart.frame.origin.y + pieChart.frame.height + 10, legend.frame.width, legend.frame.height)&#10;&#160;&#160; &#160; &#160; &#160;&#10;&#9;self.view.addSubview(legend)&#160; &#160; &#160;&#10;&#9;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="external">PNChart</a> 是一个简约，易用的第三方图表库，它支持折线图，柱形图，饼状图和圆形图的绘制；</p>
<h3 ]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS-常用第三方库4(SwiftyJSON)]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%934-SwiftyJSON/"/>
    <id>http://xinnyu.com/2015/09/20/iOS-常用第三方库4-SwiftyJSON/</id>
    <published>2015-09-20T14:14:38.000Z</published>
    <updated>2015-09-20T14:22:58.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="external">SwiftJSON</a>是用Swift写的一个快速处理JSON数据的第三方库。</p>
<h3 id="使用方法：">使用方法：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let json = JSON(data: dataFromNetworking)&#10;if let userName = json[&#34;name&#34;].string&#123;&#10;  //&#23601;&#36825;&#20040;&#31616;&#21333;&#21462;&#21040;&#20102;&#12290;&#10;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://tangplin.github.io/swiftyjson/" target="_blank" rel="external">中文说明</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="external">SwiftJSON</a>是用Swift写的一个快速处理JSON数据的第三方库。</p>
<h3 id="使用]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS-常用第三方库3(HUD)]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%933-HUD/"/>
    <id>http://xinnyu.com/2015/09/20/iOS-常用第三方库3-HUD/</id>
    <published>2015-09-20T12:21:18.000Z</published>
    <updated>2015-09-26T16:11:12.000Z</updated>
    <content type="html"><![CDATA[<p>GitHub上iOS关于HUD的第三方库实在太多了， 这三个比较常用：</p>
<ul>
<li><a href="https://github.com/relatedcode/ProgressHUD" target="_blank" rel="external">ProgressHUD</a></li>
<li><a href="https://github.com/johnlui/SwiftNotice" target="_blank" rel="external">SwiftNotice</a></li>
<li><a href="https://github.com/jdg/MBProgressHUD/tree/iOS7Style" target="_blank" rel="external">MBProgressHUD</a></li>
</ul>
<h3 id="ProgressHUD">ProgressHUD</h3><p>用法简单，一行代码搞定：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &#34;ProgressHUD.h&#34;&#10;&#10;ProgressHUD.show(&#34;&#27491;&#22312;&#21047;&#26032;&#65281;&#34;)&#10;ProgressHUD.showError(&#34;&#38169;&#35823;&#34;)&#10;ProgressHUD.showSuccess(&#34;&#21047;&#26032;&#25104;&#21151;&#65281;&#34;)&#10;&#10;ProgressHUD.dismiss()</span><br></pre></td></tr></table></figure></p>
<p>但是可自定义的属性不多；</p>
<h3 id="SwiftNotice">SwiftNotice</h3><p>用法同样简单，还支持顶部通知：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">noticeTop(&#34;&#34;) //&#39030;&#37096;&#36890;&#30693;&#10;notice(&#34;&#34;, type: NoticeType, autoClear: true)&#10;noticeOnlyText(&#34;&#34;)&#10;successNotice(&#34;&#34;)&#10;errorNotice(&#34;&#34;)</span><br></pre></td></tr></table></figure>
<h3 id="MBProgressHUD">MBProgressHUD</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[MBProgressHUD showHUDAddedTo:self.view animated:YES];&#10;dispatch_async(dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123;&#10;    // Do something...&#10;    dispatch_async(dispatch_get_main_queue(), ^&#123;&#10;        [MBProgressHUD hideHUDForView:self.view animated:YES];&#10;    &#125;);&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>自定义：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MBProgressHUD *hud = [MBProgressHUD showHUDAddedTo:self.view animated:YES];&#10;hud.mode = MBProgressHUDModeAnnularDeterminate;&#10;hud.labelText = @&#34;Loading&#34;;&#10;[self doSomethingInBackgroundWithProgressCallback:^(float progress) &#123;&#10;    hud.progress = progress;&#10;&#125; completionCallback:^&#123;&#10;    [hud hide:YES];&#10;&#125;];</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>GitHub上iOS关于HUD的第三方库实在太多了， 这三个比较常用：</p>
<ul>
<li><a href="https://github.com/relatedcode/ProgressHUD" target="_blank" rel="external">Prog]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS-常用第三方库2(MJRefresh)]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%932-MJRefresh/"/>
    <id>http://xinnyu.com/2015/09/20/iOS-常用第三方库2-MJRefresh/</id>
    <published>2015-09-20T11:52:32.000Z</published>
    <updated>2015-09-26T16:46:55.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="external">MJRefresh</a>是用法最简单的下拉刷新框架：一行代码搞定 </p>
<p>支持 UIScrollView、UITableView、UICollectionView、UIWebView 的刷新</p>
<h3 id="基础用法">基础用法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//&#35774;&#32622;&#19979;&#25289;&#21047;&#26032;&#10;var MJHeader = MJRefreshNormalHeader(refreshingTarget: self, refreshingAction: &#34;refresh&#34;)&#10;self.myTabView.header = MJHeader&#10;&#160;&#160; &#160; &#160; &#160;&#10;//&#35774;&#32622;&#19978;&#25289;&#21152;&#36733;&#10;var MJFooter = MJRefreshAutoNormalFooter(refreshingTarget: self, refreshingAction: &#34;load&#34;)&#10;self.myTabView.footer = MJFooter&#10;&#10;func load()&#123;  &#10;&#9;//&#25191;&#34892;&#21152;&#36733;&#21160;&#20316;&#10;&#9;self.myTabView.header.endRefreshing()&#10;&#125;&#10;&#10;func refresh()&#123;  &#10;&#9;//&#25191;&#34892;&#21047;&#26032;&#21160;&#20316;&#10;&#9;self.myTabView.footer.endRefreshing()&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高级用法">高级用法</h3><ol>
<li><p>下拉刷新控件的种类</p>
<p> ○ 默认（Normal）：MJRefreshNormalHeader<br> ○ 动图（Gif）：MJRefreshGifHeader</p>
</li>
<li><p>上拉刷新控件的种类</p>
<p> <em>自动刷新（Auto）</em><br> 默认（Normal）：MJRefreshAutoNormalFooter<br> 动图（Gif）：MJRefreshAutoGifFooter<br> <em>自动回弹（Back）</em><br> 默认（Normal）：MJRefreshBackNormalFooter<br> 动图（Gif）：MJRefreshBackGifFooter</p>
</li>
</ol>
<p>####<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &#35774;&#32622;&#25991;&#23383;&#10;[header setTitle:@&#34;Pull down to refresh&#34; forState:MJRefreshStateIdle];&#10;[header setTitle:@&#34;Release to refresh&#34; forState:MJRefreshStatePulling];&#10;[header setTitle:@&#34;Loading ...&#34; forState:MJRefreshStateRefreshing];&#10;// &#35774;&#32622;&#23383;&#20307;&#10;header.stateLabel.font = [UIFont systemFontOfSize:15];&#10;header.lastUpdatedTimeLabel.font = [UIFont systemFontOfSize:14];&#10;// &#35774;&#32622;&#39068;&#33394;&#10;header.stateLabel.textColor = [UIColor redColor];&#10;header.lastUpdatedTimeLabel.textColor = [UIColor blueColor];&#10;&#10;// &#38544;&#34255;&#26102;&#38388;&#10;header.lastUpdatedTimeLabel.hidden = YES;&#10;// &#38544;&#34255;&#29366;&#24577;&#10;header.stateLabel.hidden = YES;</span><br></pre></td></tr></table></figure></p>
<h4 id="下拉加载">下拉加载</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// &#35774;&#32622;&#22238;&#35843;&#65288;&#19968;&#26086;&#36827;&#20837;&#21047;&#26032;&#29366;&#24577;&#65292;&#23601;&#35843;&#29992;target&#30340;action&#65292;&#20063;&#23601;&#26159;&#35843;&#29992;self&#30340;loadMoreData&#26041;&#27861;&#65289;&#10;MJRefreshAutoGifFooter *footer = [MJRefreshAutoGifFooter footerWithRefreshingTarget:self refreshingAction:@selector(loadMoreData)];&#10;// &#35774;&#32622;&#21047;&#26032;&#22270;&#29255;&#10;[footer setImages:refreshingImages forState:MJRefreshStateRefreshing];&#10;&#10;// &#38544;&#34255;&#21047;&#26032;&#29366;&#24577;&#30340;&#25991;&#23383;&#10;footer.refreshingTitleHidden = YES;&#10;// &#22914;&#26524;&#27809;&#26377;&#19978;&#38754;&#30340;&#26041;&#27861;&#65292;&#23601;&#29992;footer.stateLabel.hidden = YES;&#10;&#10;// &#38544;&#34255;&#24403;&#21069;&#30340;&#19978;&#25289;&#21047;&#26032;&#25511;&#20214;&#10;self.tableView.footer.hidden = YES;&#10;&#10;// &#21464;&#20026;&#27809;&#26377;&#26356;&#22810;&#25968;&#25454;&#30340;&#29366;&#24577;&#10;[footer noticeNoMoreData];</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="external">MJRefresh</a>是用法最简单的下拉刷新框架：一行代码搞定 </p>
<p>支持 UIScrollVie]]>
    </summary>
    
      <category term="第三方库，iOS，Swift" scheme="http://xinnyu.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%EF%BC%8CiOS%EF%BC%8CSwift/"/>
    
      <category term="iOS" scheme="http://xinnyu.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 常用第三方库1(Alamofire)]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%931(Alamofire)/"/>
    <id>http://xinnyu.com/2015/09/20/iOS-常用第三方库1(Alamofire)/</id>
    <published>2015-09-20T11:18:20.000Z</published>
    <updated>2015-09-26T09:36:02.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="external">Alamofire</a> 是Swift版的 AFNetworking，是非常方便实用的第三方网络操作框架；</p>
<h3 id="使用方法：">使用方法：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alamofire.request(method: Method, URLString: URLStringConvertible, parameters: [String : AnyObject]?, encoding: ParameterEncoding, headers: [String : String]?).response (options: NSJSONReadingOptions, completionHandler: &#123; (NSURLRequest, NSHTTPURLResponse?, NSData?, NSError?) -&#62; Void in&#10;&#160; &#160; //&#25805;&#20316;&#25968;&#25454;&#10;&#10;&#125;)</span><br></pre></td></tr></table></figure>
<p>但是上面方法中有些参数可以省略，基本用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alamofire.request(.GET, &#34;URL&#34;).responseJSON(options: NSJSONReadingOptions.AllowFragments) &#123; (_, _, json, _) -&#62; Void in&#10;//&#25805;&#20316;&#25968;&#25454;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取数据的方法">获取数据的方法</h4><ul>
<li>response()</li>
<li>responseString(encoding: NSStringEncoding)</li>
<li>responseJSON(options: NSJSONReadingOptions)</li>
<li>responsePropertyList(options: NSPropertyListReadOptions)</li>
</ul>
<h4 id="HTTP_Methods">HTTP Methods</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Method: String &#123;&#10;    case OPTIONS = &#34;OPTIONS&#34;&#10;    case GET = &#34;GET&#34;&#10;    case HEAD = &#34;HEAD&#34;&#10;    case POST = &#34;POST&#34;&#10;    case PUT = &#34;PUT&#34;&#10;    case PATCH = &#34;PATCH&#34;&#10;    case DELETE = &#34;DELETE&#34;&#10;    case TRACE = &#34;TRACE&#34;&#10;    case CONNECT = &#34;CONNECT&#34;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="请求需要的参数parameters">请求需要的参数parameters</h4><p>类型是一个字典 [String : AnyObject]<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let parameters = [&#10;    &#34;foo&#34;: &#34;bar&#34;,&#10;    &#34;baz&#34;: [&#34;a&#34;, 1],&#10;    &#34;qux&#34;: [&#34;x&#34;: 1 , &#34;y&#34;: 2 , &#34;z&#34;: 3]&#10;]&#10;Alamofire.request(.POST, &#34;http://httpbin.org/post&#34;, parameters: parameters)</span><br></pre></td></tr></table></figure></p>
<h4 id="下载文件">下载文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alamofire.download(.GET, &#34;http://httpbin.org/stream/100&#34;) &#123; temporaryURL, response in&#10;    let fileManager = NSFileManager.defaultManager()&#10;    if let directoryURL = fileManager.URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask)[0] as? NSURL &#123;&#10;        let pathComponent = response.suggestedFilename&#10;        return directoryURL.URLByAppendingPathComponent(pathComponent!)&#10;    &#125;&#10;&#10;    return temporaryURL&#10;&#125;&#10;&#10;&#36825;&#20123;&#37117;&#21482;&#26159;Alamofire&#30340;&#24120;&#35268;&#20351;&#29992;&#65292;&#26356;&#21152;&#35814;&#32454;&#30340;&#20351;&#29992;&#26041;&#27861;&#20854;&#23448;&#26041;&#32593;&#31449;&#19978;&#26377;&#35814;&#32454;&#25551;&#36848;&#12290;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="external">Alamofire</a> 是Swift版的 AFNetworking，是非常方便实用的第三方网络操作框架；</p]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS9 网络https 错误]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS9-%E7%BD%91%E7%BB%9Chttps-%E9%94%99%E8%AF%AF/"/>
    <id>http://xinnyu.com/2015/09/20/iOS9-网络https-错误/</id>
    <published>2015-09-20T11:05:25.000Z</published>
    <updated>2015-09-20T11:07:02.000Z</updated>
    <content type="html"><![CDATA[<p>在iOS9 中，苹果将原http协议改成了https协议，使用 TLS1.2 SSL加密请求数据。</p>
<p><strong>解决办法</strong>：</p>
<p>在<em>info.plist</em>中添加<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#60;key&#62;NSAppTransportSecurity&#60;/key&#62;&#60;dict&#62;&#10;&#160;&#160;&#160;&#160;&#60;key&#62;NSAllowsArbitraryLoads&#60;/key&#62;&#10;&#160;&#160;&#160;&#160;&#60;true/&#62;&#60;/dict&#62;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在iOS9 中，苹果将原http协议改成了https协议，使用 TLS1.2 SSL加密请求数据。</p>
<p><strong>解决办法</strong>：</p>
<p>在<em>info.plist</em>中添加<br><figure class="highligh]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[CocoaPods安装使用方法]]></title>
    <link href="http://xinnyu.com/2015/09/20/CocoaPods%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://xinnyu.com/2015/09/20/CocoaPods安装使用方法/</id>
    <published>2015-09-20T10:06:32.000Z</published>
    <updated>2015-09-20T11:04:18.000Z</updated>
    <content type="html"><![CDATA[<h3 id="安装">安装</h3><p>首先安装好Ruby环境，在终端中输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure>
<p>可是在天朝，在终端中敲入这个命令之后，会发现半天没有任何反应。原因无他，因为那堵墙阻挡了cocoapods.org。</p>
<p>我们可以用淘宝的Ruby镜像来访问cocoapods。按照下面的顺序在终端中敲入依次敲入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gem sources --remove https://rubygems.org/</span><br></pre></td></tr></table></figure>
<p>等有反应之后再敲入以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gem sources <span class="operator">-a</span> http://ruby.taobao.org/</span><br></pre></td></tr></table></figure>
<p>为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gem sources <span class="operator">-l</span></span><br></pre></td></tr></table></figure>
<p>只有在终端中出现下面文字才表明你上面的命令是成功的：</p>
<blockquote>
<p>CURRENT SOURCES ***<br><a href="http://ruby.taobao.org/" target="_blank" rel="external">http://ruby.taobao.org/</a></p>
</blockquote>
<p>这时候，再次在终端中运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure>
<p>等上十几秒钟，CocoaPods就可以在你本地下载并且安装好了，不再需要其他设置。</p>
<h3 id="使用">使用</h3><p>e.g.<br><strong>利用CocaPods安装Alamofire</strong></p>
<p>在终端中进入（cd命令）你项目所在目录，然后在当前目录下，利用vim创建Podfile，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim Podfile</span><br></pre></td></tr></table></figure>
<p>然后在Podfile文件中输入以下文字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="string">'https://github.com/CocoaPods/Specs.git'</span></span><br><span class="line">platform :ios, <span class="string">'8.0'</span></span><br><span class="line">use_frameworks!</span><br><span class="line">pod <span class="string">'Alamofire'</span>, <span class="string">'~&gt; 2.0'</span></span><br></pre></td></tr></table></figure>
<p>这段文字可以在Alamofire的<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="external">GitHub</a>中找到；<br>然后保存退出。vim环境下，保存退出命令是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure>
<p>然后在终端中的当前项目目录下，运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod install</span><br></pre></td></tr></table></figure>
<p>然后CocoaPods就会帮你做好一切了，使用Alamofire只需要在项目中 import Alamofire；</p>
<p>对了，使用过CocoaPods的项目就不用之前的<del>.xcodeproj</del>文件打开了，而是使用<strong>.xcworkspace</strong>打开。</p>
<p>在这之后如果你还要添加新的第三方库的话，就只要在已经存在的Podfile中添加相应的代码然后到项目文件夹执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pod update</span><br></pre></td></tr></table></figure>
<p><em>快速更新第三方库的方法</em>：<br>在更新时使用如下代码替换之前的 <del>pod update</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pod update --verbose --no-repo-update</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="安装">安装</h3><p>首先安装好Ruby环境，在终端中输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo g]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 传值总结]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS-%E4%BC%A0%E5%80%BC%E6%80%BB%E7%BB%93/"/>
    <id>http://xinnyu.com/2015/09/20/iOS-传值总结/</id>
    <published>2015-09-20T08:12:12.000Z</published>
    <updated>2015-09-20T09:56:36.000Z</updated>
    <content type="html"><![CDATA[<p>iOS中传值的方式主要有以下几种：</p>
<ul>
<li>segue传值</li>
<li>通知传值</li>
<li>代理传值</li>
<li>单例传值</li>
<li>ShareApplication</li>
<li>NSUserdefault</li>
</ul>
<p>如果是A页面传值到B页面，之间有segue连接的话，用属性传值就可以搞定，如果从B页面传值到A页面或者之间没有直接的segue的话，就可以使用代理传值或者单例传值了。</p>
<ul>
<li><strong>segue传值</strong></li>
</ul>
<p>segue传值就是利用segue跳转时利用属性进行传值，这边就不做记录了。</p>
<ul>
<li><strong>通知传值</strong></li>
</ul>
<p>通知是一个单例类，只存在一个通知实例，一个通知会有一个对应的名字，而这个名字就是对应的观察者的接受通知的索引，每个对象都可以接收到这个广播，但是只有这个通知的名字和观察者的名字相同时，对应的观察者才可以接收到这个广播并处理对应逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//seletor: &#25509;&#25910;&#21040;&#36890;&#30693;&#21518;&#24212;&#35813;&#20570;&#30340;&#25805;&#20316;&#65307;name&#65306;&#35813;&#36890;&#30693;&#23545;&#24212;&#30340;&#21517;&#23383;&#10;//A&#21457;&#36865;&#36890;&#30693;&#10;NSNotificationCenter.defaultCenter().postNotificationName(&#34;&#36890;&#30693;&#21517;&#23383;&#34;, object: self, userInfo: [&#34;key&#34;: value])&#10;//B&#25509;&#25910;&#36890;&#30693;&#10;NSNotificationCenter.defaultCenter().addObserver(self, selector: &#34;&#25509;&#25910;&#21040;&#36890;&#30693;&#21518;&#35201;&#25191;&#34892;&#30340;&#26041;&#27861;:&#34;, name: &#34;&#36890;&#30693;&#21517;&#23383;&#34;, object: nil)&#10;//&#21516;&#26102;&#23454;&#29616;&#25509;&#21463;&#36890;&#30693;&#21518;&#35201;&#25191;&#34892;&#30340;&#26041;&#27861;&#10;func &#25509;&#25910;&#21040;&#36890;&#30693;&#21518;&#35201;&#25191;&#34892;&#30340;&#26041;&#27861;(aNotification:NSNotification)&#123;&#10;&#9;//value = aNotification.userInfo[&#34;key&#34;]&#10;&#125;&#10;B&#26041; &#31227;&#38500;&#30417;&#21548;removeObserver (&#19968;&#23450;&#35201;&#35760;&#24471;)&#10;deinit &#123;&#10;&#9;&#9;NSNotificationCenter.defaultCenter().removeObserver(self)&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>代理传值</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//&#22768;&#26126;&#22996;&#25176;&#10;protocol passValueDele&#123;&#10;&#160; &#160; func passValue(value:String)&#10;&#125;&#10;&#10;//&#25509;&#21463;&#22996;&#25176;&#65292;&#24182;&#23450;&#20041;&#19968;&#20010;&#22996;&#25176;&#31867;&#30340;&#23545;&#35937;&#65306;&#10;let vc1 = self.storyboard?.instantiateViewControllerWithIdentifier(&#34;detail&#34;) as! ViewController&#10;&#10;vc1.delegate1 = self&#10;func passValue(value:String)&#123;  &#10;&#9;&#9;//&#24471;&#21040;value&#20043;&#21518;&#25191;&#34892;&#25805;&#20316;&#10;&#125;&#10;&#10;//&#22312;&#22996;&#25176;&#31867;&#20013;&#22768;&#26126;&#19968;&#20010;&#22996;&#25176;&#21464;&#37327;&#65292;&#24182;&#35843;&#29992;&#26041;&#27861;&#20256;&#20540;&#65307;&#10;weak var delegate1:passValueDele?&#160; //&#27880;&#24847;&#29992;weak&#65292;&#38450;&#27490;&#24490;&#29615;&#24341;&#29992;&#10;delegate1?.passValue(&#34;value&#34;)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>单例传值</strong></li>
</ul>
<p>简单来说单例传值就是创建一个类的单例，各个ViewController共享数据。</p>
<p>先创建一个单例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SingleTonClass: NSObject &#123;&#10;    var value:String?&#10;    struct singleTon &#123;&#10;        static var once_t:dispatch_once_t = 0&#10;        static var currentDataSong:CurrentDataSong?&#10;    &#125;&#10;    &#10;    class func shareCurrentDataSong()-&#62;CurrentDataSong&#123;&#10;        dispatch_once(&#38;singleTon.once_t) &#123; () -&#62; Void in&#10;            singleTon.SingleTonClass = SingleTonClass()&#10;        &#125;&#10;        return singleTon.SingleTonClass!&#10;    &#125; &#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在需要传值的ViewController中给单例的属性赋值；<br>这样就可以在需要值的ViewController中得到要传的值了；</p>
<ul>
<li><strong>ShareAppDelegate传值</strong></li>
</ul>
<p>和单例的原理一样，不过这个单例利用的是AppDelegate；</p>
<ul>
<li><strong>NSUserdefault传值</strong></li>
</ul>
<p>此方法试用于轻量级的数据转移，就是把需要传的值先存入到NSUserdefault中，然后在需要值的地方从NSUserdefault中取值。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>iOS中传值的方式主要有以下几种：</p>
<ul>
<li>segue传值</li>
<li>通知传值</li>
<li>代理传值</li>
<li>单例传值</li>
<li>ShareApplication</li>
<li>NSUserdefault</li>
</]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[NSTimer 相关]]></title>
    <link href="http://xinnyu.com/2015/09/20/NSTimer-%E7%9B%B8%E5%85%B3/"/>
    <id>http://xinnyu.com/2015/09/20/NSTimer-相关/</id>
    <published>2015-09-20T08:06:49.000Z</published>
    <updated>2015-09-20T08:08:21.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li>定义一个 NSTimer</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var timer1:NSTimer! = NSTimer.scheduledTimerWithTimeInterval(1, target: self, selector: &#34;addOneMin:&#34;, userInfo: nil, repeats: true)&#10;//selector &#26159;&#19968;&#20010;&#36873;&#25321;&#22120;,&#38656;&#35201;&#23450;&#20041;&#19968;&#20010;&#20989;&#25968;,&#24403;&#20989;&#25968;&#38656;&#35201;&#20256;&#21442;&#26102;,&#20989;&#25968;&#21517;&#21518;&#24212;&#35813;&#21152;&#20882;&#21495;</span><br></pre></td></tr></table></figure>
<ol>
<li>启动 NSTimer</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.fire()&#10;`</span><br></pre></td></tr></table></figure>
<ol>
<li>暂停</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.invalidate()</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li>定义一个 NSTimer</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var timer1:NSTimer! = N]]>
    </summary>
    
  </entry>
  
</feed>
