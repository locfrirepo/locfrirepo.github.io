<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Xinnyu's blog]]></title>
  <subtitle><![CDATA[Walk steps step by step]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://xinnyu.com/"/>
  <updated>2015-10-15T08:19:34.000Z</updated>
  <id>http://xinnyu.com/</id>
  
  <author>
    <name><![CDATA[xinnyu]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Swift 中泛型的使用]]></title>
    <link href="http://xinnyu.com/2015/10/15/Swift-%E4%B8%AD%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://xinnyu.com/2015/10/15/Swift-中泛型的使用/</id>
    <published>2015-10-15T07:09:58.000Z</published>
    <updated>2015-10-15T08:19:34.000Z</updated>
    <content type="html"><![CDATA[<p>对于类型安全(type-safe)语言，一个常见的问题就是如何编写适用于多种类型输入的程序。想象一下，两个整型数相加和两个浮点数相加的程序看起来应该非常类似，甚至一模一样才对。唯一的区别就是变量的类型不同。</p>
<p>在强类型语言中，你需要去定义诸如addInts, addFloats, addDoubles 等方法来正确地处理参数及返回值。</p>
<p>许多编程语言已经解决了这个问题。例如，在C++中，使用Template来解决。而Swift，Java和C#则采用了泛型来解决这个问题。</p>
<p>下面用有序字典（Ordered Dictionaries）来简单说明一下泛型的用法：</p>
<p>和数组不同的是，包括Swift在内地很多编程语言和框架都不保证集合(sets)和字典(dictionaries)的数据存储顺序。有序字典和普通的字典类似，不同之处在于它的key是有序的。</p>
<h4 id="创建有序字典">创建有序字典</h4><p>点击“文件\新建\文件…”新建一个文件，并选择“IOS\Source\Swift File”。点击“下一步”并把这个文件命名为“OrderedDictionary”。最后，点击“创建”。</p>
<p>你会得到一个空的Swift文件，加这样一段代码进去：</p>
<figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OrderedDictionary</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到现在为止应该都没有什么问题。通过语义可以看出这个对象是一个结构体。</p>
<p>现在你需要将其一般化，以便它能够装载你需要的任何类型的数据。通过下列改变你对Swift中“结构”的定义：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OrderedDictionary</span><span class="inheritance">&lt;<span class="parent">KeyType</span></span>, <span class="title">ValueType</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在尖括弧中的元素是通用类型的参数。KeyType和ValueType不是他们自身的类型，而是你可以使用在结构里定义取代的类型。现在就简洁清新许多了！</p>
<p>最简单的实现一个有顺序的字典是保持一个数组和一个字典。字典中将会装载衍射，而数组将装载keys的顺序。</p>
<p>在结构体内部的定义中，加入以下的代码：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">typealias ArrayType = <span class="keyword">[</span>KeyType]</span><br><span class="line">typealias DictionaryType = <span class="keyword">[</span>KeyType: ValueType] </span><br><span class="line">var<span class="instruction"> array </span>=<span class="function"> ArrayType(</span><span class="function">)</span></span><br><span class="line">var dictionary =<span class="function"> DictionaryType(</span><span class="function">)</span></span><br></pre></td></tr></table></figure>
<p>这样声明有两个目的，就像上例描述的，有两种类型的用于给已经存在的类型的取新的名称的别名。在这，你将分别地为后面的数组和字典赋值了别名。声明别名是将复杂类型定义为更短名称的类型的一种非常有效的方式。</p>
<p>你将注意怎么样从结构体中定义用“KeyType”和“ValueType”的参数类型中替换类型。上例的”KeyTypes”是数组类型的。当然这是没有这样的类型的“KeyType”；当在一般的实例化时，将替代Swift像对OrderedDictionary的类型的一切类型通过。</p>
<p>就因为这样，你将会注意到编译错误：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Type</span> <span class="string">'Keytype'</span> does <span class="keyword">not</span> conform <span class="keyword">to</span> protocol <span class="string">'Hashable'</span></span><br></pre></td></tr></table></figure>
<p>这是因为你的字典Key没有遵循Hashable协议； 我们可以手动修改代码让Key遵循Hashable协议：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OrderedDictionary</span><span class="inheritance">&lt;<span class="parent">KeyType</span></span>: <span class="title">Hashable</span>, <span class="title">ValueType</span></span></span><br></pre></td></tr></table></figure>
<p>接下来我们就需要正式建立有序字典了；</p>
<ul>
<li>添加count属性</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.array.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加插入和移除方法</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">removeAtIndex</span><span class="params">(index: Int)</span></span> -&gt; (<span class="type">KeyType</span>, <span class="type">ValueType</span>) &#123;</span><br><span class="line">    precondition(index &lt; <span class="keyword">self</span>.array.<span class="built_in">count</span>, <span class="string">"Index 超出范围"</span>)</span><br><span class="line">    <span class="built_in">assert</span>(index &lt; <span class="keyword">self</span>.array.<span class="built_in">count</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> key = <span class="keyword">self</span>.array.removeAtIndex(index)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">self</span>.dictionary.removeValueForKey(key)!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(value: ValueType, forKey key: KeyType, atIndex index:Int)</span></span> -&gt; <span class="type">ValueType</span>? &#123;</span><br><span class="line">    <span class="keyword">var</span> adjustedIndex = index</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> existingValue = <span class="keyword">self</span>.dictionary[key]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> existingValue != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> existingIndex = <span class="keyword">self</span>.array.indexOf(key)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> existingIndex &lt; index &#123;</span><br><span class="line">            adjustedIndex--</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.array.removeAtIndex(existingIndex!)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.array.insert(key, atIndex: adjustedIndex)</span><br><span class="line">    <span class="keyword">self</span>.dictionary[key] = value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> existingValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在结构体内如果方法需要修改结构体内的属性的话，要在方法前加mutating关键字；</p>
<ul>
<li>添加下标访问方法：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(key: <span class="type">KeyType</span>) -&gt; <span class="type">ValueType</span>? &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.dictionary[key]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">_</span> = <span class="keyword">self</span>.array.indexOf(key) &#123;&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.array.append(key)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.dictionary[key] = newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt;(<span class="type">KeyType</span>, <span class="type">ValueType</span>) &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        precondition(index &lt; <span class="keyword">self</span>.array.<span class="built_in">count</span>, <span class="string">"Index 超出范围"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> key = <span class="keyword">self</span>.array[index]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> value = <span class="keyword">self</span>.dictionary[key]!</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (key, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>这样我们就利用泛型创建了一个有序字典。
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>对于类型安全(type-safe)语言，一个常见的问题就是如何编写适用于多种类型输入的程序。想象一下，两个整型数相加和两个浮点数相加的程序看起来应该非常类似，甚至一模一样才对。唯一的区别就是变量的类型不同。</p>
<p>在强类型语言中，你需要去定义诸如addInts, a]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift单例]]></title>
    <link href="http://xinnyu.com/2015/10/15/Swift%E5%8D%95%E4%BE%8B/"/>
    <id>http://xinnyu.com/2015/10/15/Swift单例/</id>
    <published>2015-10-15T06:58:10.000Z</published>
    <updated>2015-10-15T13:45:21.000Z</updated>
    <content type="html"><![CDATA[<p>单例是一个在 Cocoa 中很常用的模式了。对于一些希望能在全局方便访问的实例，或者在 app 的生命周期中只应该存在一个的对象，我们一般使用单例来存储和访问。在 Objective-C 中单例的公认的写法类似下面这样：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyManager</span></span></span><br><span class="line">+ (<span class="keyword">id</span>)sharedManager &#123;</span><br><span class="line">    <span class="keyword">static</span> MyManager *staticInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        staticInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> staticInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>使用 GCD 中的 dispatch_once_t 可以保证里面的代码只被调用一次，以此保证单例在线程上的安全。</p>
<p>因为在 Swift 中可以无缝直接使用 GCD，所以我们可以很方便地把类似方式的单例用 Swift 进行改写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyManager</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">sharedManager</span> : <span class="title">MyManager</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Static</span> </span>&#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">var</span> onceToken : dispatch_once_t = <span class="number">0</span></span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">var</span> staticInstance : <span class="type">MyManager</span>? = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_once(&amp;<span class="type">Static</span>.onceToken) &#123;</span><br><span class="line">            <span class="type">Static</span>.staticInstance = <span class="type">MyManager</span>()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Static</span>.staticInstance!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 Swift 现在还暂时不支持存储的 class var，所以我们需要使用一个 struct 来存储类型变量。</p>
<p>这样的写法当然没什么问题，但是在 Swift 里我们其实有一个更简单的保证线程安全的方式，那就是 let。把上面的写法简化一下，可以变成：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyManager</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">sharedManager</span> : <span class="title">MyManager</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Static</span> </span>&#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance : <span class="type">MyManager</span> = <span class="type">MyManager</span>()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Static</span>.sharedInstance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有另一种更受大家欢迎，并被认为是当前的最佳实践的做法。由于现在 class 不支持存储式的 property，我们想要使用一个只存在一份的属性时，就只能将其定义在全局的 scope 中。值得庆幸的是，在 Swift 拥有访问级别控制后，我们可以在变量定义前面加上 private 关键字，使这个变量只在当前文件中可以被访问。这样我们就可以写出一个没有嵌套的，语法上也更简单好看的单例了：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> sharedInstance = MyManager()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyManager</span>  &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">var</span> <span class="title">sharedManager</span> : <span class="title">MyManager</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sharedInstance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一种是最简单也是最实用的，是swift给的语法糖</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>单例是一个在 Cocoa 中很常用的模式了。对于一些希望能在全局方便访问的实例，或者在 app 的生命周期中只应该存在一个的对象，我们一般使用单例来存储和访问。在 Objective-C 中单例的公认的写法类似下面这样：</p>
<figure class="highlig]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式]]></title>
    <link href="http://xinnyu.com/2015/09/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://xinnyu.com/2015/09/29/设计模式/</id>
    <published>2015-09-29T06:52:05.000Z</published>
    <updated>2015-09-29T16:16:34.000Z</updated>
    <content type="html"><![CDATA[<p>设计模式是为了解决特定问题而出现的；</p>
<p>设计模式的基本原则：</p>
<ul>
<li><p>开闭原则<br>模块应该对扩展开放而对修改关闭；</p>
</li>
<li><p>里氏代换原则<br>父类和子类之间的方法可以相互调换，从而方便修改；多态</p>
</li>
<li><p>依赖倒转原则<br>抽象不依赖于细节，细节依赖于抽象；</p>
</li>
<li><p>接口隔离原则<br>尽量保证接口只做必要的事情；</p>
</li>
<li><p>合成/聚合复用</p>
</li>
</ul>
<h3 id="适配器模式">适配器模式</h3><p>比如iOS从网络请求加载数据，更新UI的时候，我们会初始化出一个model，随着后续版本的升级，这个model会持续添加参数，或者减少参数；此时如果我们直接修改这个model的话，那么就要同时修改与这个model相匹配的view，这样就会一只在两者之间修改来修改去，适配器模式就是为了解决这种问题存在的。</p>
<p>如果你运用了适配器模式，那么我们的model不会直接与view接触，它会先和适配器接触，然后再通过适配器去更新UI</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>设计模式是为了解决特定问题而出现的；</p>
<p>设计模式的基本原则：</p>
<ul>
<li><p>开闭原则<br>模块应该对扩展开放而对修改关闭；</p>
</li>
<li><p>里氏代换原则<br>父类和子类之间的方法可以相互调换，从而方便修改；多态</p>
<]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac终端command not found 解决办法]]></title>
    <link href="http://xinnyu.com/2015/09/26/Mac%E7%BB%88%E7%AB%AF%E6%8F%90%E7%A4%BA-command-not-found%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://xinnyu.com/2015/09/26/Mac终端提示-command-not-found解决办法/</id>
    <published>2015-09-26T14:37:57.000Z</published>
    <updated>2015-09-26T15:17:27.000Z</updated>
    <content type="html"><![CDATA[<p>在bash_profile中添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/.rvm/bin"</span> <span class="comment"># Add RVM to PATH for scripting</span></span><br><span class="line"></span><br><span class="line">[[ <span class="operator">-s</span> <span class="string">"<span class="variable">$HOME</span>/.rvm/scripts/rvm"</span> ]] &amp;&amp; <span class="built_in">source</span> <span class="string">"<span class="variable">$HOME</span>/.rvm/scripts/rvm"</span> <span class="comment"># Load RVM into a shell session *as a function*</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>在bash_profile中添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</s]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac自带Vim7.3不能使用系统剪切板解决方案]]></title>
    <link href="http://xinnyu.com/2015/09/26/Mac%E8%87%AA%E5%B8%A6Vim7-3%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%89%AA%E5%88%87%E6%9D%BF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://xinnyu.com/2015/09/26/Mac自带Vim7-3不能使用系统剪切板解决方案/</id>
    <published>2015-09-26T11:35:44.000Z</published>
    <updated>2015-09-26T14:33:39.000Z</updated>
    <content type="html"><![CDATA[<p>用了Mac自带的Vim之后发现yy复制的内容和剪切板不同步，谷歌之，找到2种方法：</p>
<ul>
<li>“+y </li>
<li>在 ~/.vimrc 里增加 set clipboard=unnamed</li>
</ul>
<p>但是完全不起任何作用，经过一番折腾之后才知道是Mac自带的Vim7.3版本不支持使用系统剪切板；<br>于是就安装了MacVim，结果试了之后还是不管用，执行<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vim</span> --<span class="keyword">version</span> | <span class="keyword">grep</span> clip</span><br></pre></td></tr></table></figure></p>
<p>结果还是：</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">clientserver -clipboard +cmdline_compl +cmdline_hist +cmdline_info +comments </span><br><span class="line"></span>-<span class="ruby">xterm_clipboard -xterm_save</span></span><br></pre></td></tr></table></figure>
<p>原因是就算你安装了MacVim使用了Vim7.4系统自带的Terminal还是会默认使用自带的7.3版本；</p>
<p>所以只要在profile中添加如下语句就可以解决问题了；</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alias</span> <span class="title">vim</span>=<span class="string">"/Applications/MacVim.app/Contents/MacOS/Vim"</span></span><br></pre></td></tr></table></figure>
<p>之后你在终端使用vim也会调用MacVim中的7.4版本了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>用了Mac自带的Vim之后发现yy复制的内容和剪切板不同步，谷歌之，找到2种方法：</p>
<ul>
<li>“+y </li>
<li>在 ~/.vimrc 里增加 set clipboard=unnamed</li>
</ul>
<p>但是完全不起任何作用，经过一番折腾]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Dynamics动画]]></title>
    <link href="http://xinnyu.com/2015/09/26/Dynamics%E5%8A%A8%E7%94%BB/"/>
    <id>http://xinnyu.com/2015/09/26/Dynamics动画/</id>
    <published>2015-09-25T17:29:21.000Z</published>
    <updated>2015-09-26T17:34:58.000Z</updated>
    <content type="html"><![CDATA[<p>UIKit Dynamics是iOS7中新推出的，可以模拟现实的二维动画效果，开发出逼真的物理动画。</p>
<h3 id="关键类">关键类</h3><ul>
<li>UIDynamicAnimator：封装了底层的物理引擎，为动力项（UIDynamicItem）提供物理相关的功能和动画；</li>
<li>UIDynamicBehavior，动力行为，为动力项提供不同的物理行为；</li>
<li>UIDynamicItem，动力项，相当于现实世界中的一个基本物体；</li>
</ul>
<h3 id="使用方法">使用方法</h3><ul>
<li>创建一个UIDynamicAnimator</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIDynamicAnimator</span> *dynamicAnimate;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIDynamicAnimator</span> *)dynamicAnimate&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_dynamicAnimate) &#123;</span><br><span class="line">        _dynamicAnimate = [[<span class="built_in">UIDynamicAnimator</span> alloc] initWithReferenceView:<span class="keyword">self</span><span class="variable">.gameView</span>];</span><br><span class="line">        _dynamicAnimate<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dynamicAnimate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后就可以把动力行为加到动画中了</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="title">[self.dynamicAnimate addBehavior:_dropItemBehavior]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>UIKit Dynamics是iOS7中新推出的，可以模拟现实的二维动画效果，开发出逼真的物理动画。</p>
<h3 id="关键类">关键类</h3><ul>
<li>UIDynamicAnimator：封装了底层的物理引擎，为动力项（UIDynamicItem）提供物理]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用融云和LeanCloud 创建一个IM应用]]></title>
    <link href="http://xinnyu.com/2015/09/21/%E4%BD%BF%E7%94%A8%E8%9E%8D%E4%BA%91%E5%92%8CLeanCloud-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAIM%E5%BA%94%E7%94%A8/"/>
    <id>http://xinnyu.com/2015/09/21/使用融云和LeanCloud-创建一个IM应用/</id>
    <published>2015-09-20T17:39:23.000Z</published>
    <updated>2015-09-21T06:29:43.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.rongcloud.cn/" target="_blank" rel="external">融云</a> 是国内一家专门为APP开发者提供IM服务的公司，利用它提供的SDK可以快速使你的APP集成IM通讯能力。<br>详细的使用方法在它官网的开发文档中有提供，但是不得不吐槽的就是它的开发文档写的实在太乱了让人有种无从下手的感觉，下面简单记录一下使用过程。</p>
<h3 id="导入SDK">导入SDK</h3><p>推荐使用CocoaPods导入：</p>
<ol>
<li>在Podfile中添加：</li>
</ol>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="title">pod</span> <span class="string">'RongCloudIMKit'</span></span><br></pre></td></tr></table></figure>
<ol>
<li>然后执行命令：</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pod <span class="keyword">install</span></span><br></pre></td></tr></table></figure>
<h3 id="获取Token">获取Token</h3><p>Token 也叫用户令牌，是 SDK 端用来连接融云服务器的凭证，每个用户连接服务器都需要一个 Token。每次初始化连接服务器时，都需要向服务器提交 Token。<br>获取Token需要注册一个融云的账号，然后新建一个应用，之后在API调试中填写userid（用户唯一标示符）、name（用户昵称）、portraitUri（头像url）就可以获得一个测试用的Token。</p>
<h3 id="初始化和测试连接">初始化和测试连接</h3><p>获得测试用的Token之后就可以利用AppKey（创建应用时融云给你的应用标示符）和Token对应用进行初始化了：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用AppKey初始化     RCIM.sharedRCIM().initWithAppKey("82hegw5uh4r8x")      </span></span><br><span class="line"><span class="comment">//用Token测试连接</span></span><br><span class="line">RCIM<span class="built_in">.</span>sharedRCIM()<span class="built_in">.</span>connectWithToken(token, success: &#123; (str:<span class="built_in">String</span><span class="subst">!</span>) <span class="subst">-&gt; </span><span class="literal">Void</span> <span class="keyword">in</span></span><br><span class="line">	print(<span class="string">"连接成功！"</span>)       </span><br><span class="line">  <span class="comment">//连接成功后设置当前登陆用户信息</span></span><br><span class="line">	RCIMClient<span class="built_in">.</span>sharedRCIMClient()<span class="built_in">.</span>currentUserInfo = RCUserInfo(userId: id, name: name, portrait: avatorURL)</span><br><span class="line">            </span><br><span class="line">	<span class="comment">//在UserDefaults中保存Token </span></span><br><span class="line">	NSUserDefaults<span class="built_in">.</span>standardUserDefaults()<span class="built_in">.</span>setObject(token, forKey: <span class="string">"kDeviceToken"</span>)</span><br><span class="line">	<span class="comment">//在主线程中调用更新UI</span></span><br><span class="line">  dispatch_async(dispatch_get_main_queue(), &#123; () <span class="subst">-&gt; </span><span class="literal">Void</span> <span class="keyword">in</span></span><br><span class="line">                </span><br><span class="line">	&#125;)&#125;,</span><br><span class="line">	err<span class="subst">or</span>: &#123; (_) <span class="subst">-&gt; </span><span class="literal">Void</span> <span class="keyword">in</span></span><br><span class="line">		print(<span class="string">"连接错误！"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	&#123; () <span class="subst">-&gt; </span><span class="literal">Void</span> <span class="keyword">in</span></span><br><span class="line">		print(<span class="string">"Token不正确！"</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连接成功后启动单聊会话">连接成功后启动单聊会话</h3><p>融云在它的SDK中已经集成聊天用户界面，所以我们只要创建一个RCConversationViewController的实例就能使用它提供的用户界面了，同时用户界面也支持自定义，这部分在官网的开发文档中有详细的介绍，这里就不做赘述。<br>需要注意的是：要使用RCConversationViewController，必须给它的几个属性赋值：</p>
<ul>
<li>conversationType：聊天类型，有单聊、群聊等等</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">self<span class="class">.conversationType</span> = RCConversationType<span class="class">.ConversationType_PRIVATE</span> <span class="comment">//这里的PRIVATE是单聊</span></span><br></pre></td></tr></table></figure>
<ul>
<li>targetId：聊天目标用户id</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">self<span class="class">.targerId</span> = <span class="string">""</span></span><br></pre></td></tr></table></figure>
<ul>
<li>userName:聊天目标用户的昵称</li>
</ul>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="literal">self</span>.<span class="keyword">user</span>Name = <span class="string">""</span></span><br></pre></td></tr></table></figure>
<ul>
<li>title:聊天界面显示的标题</li>
</ul>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="literal">self</span>.title = <span class="literal">self</span>.<span class="keyword">user</span>Name</span><br></pre></td></tr></table></figure>
<p>RCConversationViewController中还有其他很多的属性可以自定义，比如用户头像形状之类的，这些可以在它的头文件中找到。</p>
<h3 id="测试单聊">测试单聊</h3><p>设置好以上内容之后，单聊的工作就已经做好了，现在我们可以测试单聊的效果，这里由于还没有其他的用户，我们就先和自己聊天来测试一下单聊的效果；<br>把targerId设置成已经登录的id，然后就可以自己和自己聊天了，内部集成的界面还是挺简洁易用的，虽然是自己和自己聊天，但是他也不是在本地操作的，也要经过融云的服务器，所以你把网络断开的情况下是不能发出信息的。<br>到这里单聊已经实现了，但是你会发现聊天界面他是不会显示用户头像的，虽然你在初始化的时候给了一个头像的url，但是他是不会加载出来的，不得不说这一点确实很脑残，主要原因是融云为了安全起见，他的服务器是不会储存用户信息的，在融云那边只有一个Token和userid的对应关系，和你发送给他的好友关系，也就是说你的用户信息需要自己在用一个服务器存起来，然后向融云提供一个用户信息提供者；</p>
<h3 id="设置用户信息提供者">设置用户信息提供者</h3><p>要设置用户信息提供者首先要实现RCIMUserInfoDataSource协议，所以我们要在APP启动的时候让Appdelegate实现协议，然后：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">func getUserInfoWithUserId(<span class="keyword">user</span>Id: String!, completion: ((RCUserInfo!) -&gt; Void)!) &#123;</span><br><span class="line">        let <span class="keyword">user</span>Info = RCUserInfo()</span><br><span class="line">        <span class="keyword">user</span>Info.<span class="keyword">user</span>Id = <span class="keyword">user</span>Id</span><br><span class="line">        switch <span class="keyword">user</span>Id&#123;</span><br><span class="line">        case <span class="string">"xinnyu"</span>:</span><br><span class="line">            <span class="keyword">user</span>Info.name = <span class="string">"潘新宇"</span></span><br><span class="line">            <span class="keyword">user</span>Info.portraitUri = <span class="string">"http://7xl9qm.com1.z0.glb.clouddn.com/avatar.png"</span></span><br><span class="line">        case <span class="string">"liuchuqi"</span>:</span><br><span class="line">            <span class="keyword">user</span>Info.name = <span class="string">"A"</span></span><br><span class="line">            <span class="keyword">user</span>Info.portraitUri = <span class="string">"http://www4.qqjay.com/u/files/2011/1216/d3302821f418fc5539398cb3ba72cd8c.jpg"</span></span><br><span class="line">        case <span class="string">"lijie"</span>:</span><br><span class="line">            <span class="keyword">user</span>Info.name = <span class="string">"B"</span></span><br><span class="line">            <span class="keyword">user</span>Info.portraitUri = <span class="string">"http://image.photophoto.cn/nm-6/018/030/0180300244.jpg"</span></span><br><span class="line">        case <span class="string">"tansanxiang"</span>:</span><br><span class="line">            <span class="keyword">user</span>Info.name = <span class="string">"C"</span></span><br><span class="line">            <span class="keyword">user</span>Info.portraitUri = <span class="string">"http://cdn.duitang.com/uploads/item/201407/26/20140726221707_i4ZnL.thumb.224_0.jpeg"</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            print(<span class="string">"没有这个用户"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        completion(<span class="keyword">user</span>Info)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.rongcloud.cn/" target="_blank" rel="external">融云</a> 是国内一家专门为APP开发者提供IM服务的公司，利用它提供的SDK可以快速使你的APP集成IM通讯能力。<br>详细的使用方法在]]>
    </summary>
    
      <category term="Swift" scheme="http://xinnyu.com/tags/Swift/"/>
    
      <category term="iOS" scheme="http://xinnyu.com/tags/iOS/"/>
    
      <category term="iOS" scheme="http://xinnyu.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用AVPlayer 播放在线音频,并实现后台锁屏播放，自动连播]]></title>
    <link href="http://xinnyu.com/2015/09/21/%E4%BD%BF%E7%94%A8AVPlayer-%E6%92%AD%E6%94%BE%E5%9C%A8%E7%BA%BF%E9%9F%B3%E9%A2%91/"/>
    <id>http://xinnyu.com/2015/09/21/使用AVPlayer-播放在线音频/</id>
    <published>2015-09-20T16:17:37.000Z</published>
    <updated>2015-09-20T17:50:11.000Z</updated>
    <content type="html"><![CDATA[<p>在iOS开发中，AVAudioPlayer不是不能播放在线音频的，要播放在线音频只能用以下几个方法：</p>
<ul>
<li>AVPlayer </li>
<li>MPMoviePlayerController 能实现音乐流播（但是此方法苹果在iOS9中已经不推荐使用了）</li>
<li>Audioqueue，Audiostream （太复杂）</li>
<li>第三方库AudioStreamer（只能播放在线音频）</li>
</ul>
<p>所以用AVPlayer来实现在线音频播放是最好的选择；一下就是利用AVPlayer实现音乐流播并实现后台锁屏播放和设置自动连播的大概步骤：</p>
<p>项目源代码：<a href="https://github.com/xinnyu/DouBanFM" target="_blank" rel="external">Swift 2.0 版豆瓣电台</a></p>
<h3 id="初始化">初始化</h3><p>先声明AVplayer和AVPlayerItem的实例：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> musicPlayer</span>:AVPlayer!</span><br><span class="line"><span class="variable"><span class="keyword">var</span> playerItem</span>:AVPlayerItem?</span><br></pre></td></tr></table></figure></p>
<p>然后在需要的播放音频的地方给它赋值：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">self<span class="class">.musicPlayer</span> = <span class="function"><span class="title">AVPlayer</span><span class="params">()</span></span></span><br><span class="line">let playerLayer = <span class="function"><span class="title">AVPlayerLayer</span><span class="params">(player: self.musicPlayer)</span></span></span><br><span class="line">self<span class="class">.view</span><span class="class">.layer</span><span class="class">.addSublayer</span>(playerLayer)</span><br><span class="line">      </span><br><span class="line">let url = <span class="function"><span class="title">NSURL</span><span class="params">(string: <span class="string">"   "</span>)</span></span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//替换当前的playerItem</span></span><br><span class="line">self<span class="class">.musicPlayer</span><span class="class">.replaceCurrentItemWithPlayerItem</span>(playerItem)</span><br><span class="line"><span class="comment">//开始播放</span></span><br><span class="line">self<span class="class">.musicPlayer</span><span class="class">.play</span>()</span><br></pre></td></tr></table></figure></p>
<p>以上就是实现播放在线音频的代码，但是如果要实现后台播放和自动连播的话，还要做以下工作：</p>
<h3 id="自动连播">自动连播</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当播放完成了之后发送通知，继续播放</span></span><br><span class="line"><span class="tag">NSNotificationCenter</span><span class="class">.defaultCenter</span>()<span class="class">.addObserver</span>(self, <span class="attribute">selector</span>: <span class="string">"playerItemDidReachEnd:"</span>, <span class="attribute">name</span>: AVPlayerItemDidPlayToEndTimeNotification, <span class="attribute">object</span>: playerItem)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//没有播放完成的通知       </span></span><br><span class="line"><span class="tag">NSNotificationCenter</span><span class="class">.defaultCenter</span>()<span class="class">.addObserver</span>(self, <span class="attribute">selector</span>: <span class="string">"playerItemDidNotReachEnd"</span>, <span class="attribute">name</span>: AVPlayerItemFailedToPlayToEndTimeNotification, <span class="attribute">object</span>: playerItem)</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受到通知后响应的方法</span></span><br><span class="line"><span class="tag">func</span> <span class="tag">playerItemDidReachEnd</span>(<span class="attribute">aNotification</span>:NSNotification)&#123;</span><br><span class="line">	<span class="comment">//自动播放相关</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">func</span> <span class="tag">playerItemDidNotReachEnd</span>(<span class="attribute">aNotification</span>:NSNotification)&#123;</span><br><span class="line">	<span class="comment">//歌曲没有正常播放到结束</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>后台播放</em></p>
<p>如果是播放本地音频的话，后台播放只要在APP启动时加上：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">let session = AVAudioSession.<span class="function"><span class="title">sharedInstance</span><span class="params">()</span></span></span><br><span class="line">try! session.<span class="function"><span class="title">setCategory</span><span class="params">(AVAudioSessionCategoryPlayback)</span></span></span><br><span class="line">try! session.<span class="function"><span class="title">setActive</span><span class="params">(true)</span></span></span><br></pre></td></tr></table></figure>
<p>然后在info.plist文件中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>UIBackgroundModes<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">string</span>&gt;</span>audio<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">array</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>即可。</p>
<p>但是如果每一首歌都要请求网络的话，只做上述工作时行不通的，还要在实例化AVPlayer的地方加上：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后台播放</span></span><br><span class="line">var bgTask:<span class="built_in">UIBackgroundTaskIdentifier</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">UIApplication</span><span class="variable">.sharedApplication</span>()<span class="variable">.applicationState</span> == <span class="built_in">UIApplicationState</span><span class="variable">.Background</span> &#123;</span><br><span class="line">	<span class="keyword">self</span><span class="variable">.musicPlayer</span><span class="variable">.play</span>()</span><br><span class="line">	netMusicIsPlaying = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">	let app:<span class="built_in">UIApplication</span> = <span class="built_in">UIApplication</span><span class="variable">.sharedApplication</span>()</span><br><span class="line">	let newTask:<span class="built_in">UIBackgroundTaskIdentifier</span> = app<span class="variable">.beginBackgroundTaskWithExpirationHandler</span>(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> newTask != <span class="built_in">UIBackgroundTaskInvalid</span> &#123;</span><br><span class="line">	app<span class="variable">.endBackgroundTask</span>(bgTask)</span><br><span class="line">	&#125;</span><br><span class="line">	bgTask = newTask</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">self</span><span class="variable">.musicPlayer</span><span class="variable">.play</span>()</span><br><span class="line">	netMusicIsPlaying = <span class="literal">true</span></span><br><span class="line">	isPlayOffline = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样才能实现真正的后台播放。</p>
<h3 id="锁屏界面和控制中心添加详情">锁屏界面和控制中心添加详情</h3><p>首先要作以下准备工作</p>
<ul>
<li>在applicationDidEnterBackground中添加：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">application.<span class="function"><span class="title">beginReceivingRemoteControlEvents</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>在ViewDidAppear中添加：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">UIApplication.<span class="function"><span class="title">sharedApplication</span><span class="params">()</span></span>.<span class="function"><span class="title">beginReceivingRemoteControlEvents</span><span class="params">()</span></span></span><br><span class="line">self.<span class="function"><span class="title">becomeFirstResponder</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>在viewDidDisappear中添加：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">UIApplication.<span class="function"><span class="title">sharedApplication</span><span class="params">()</span></span>.<span class="function"><span class="title">endReceivingRemoteControlEvents</span><span class="params">()</span></span></span><br><span class="line">self.<span class="function"><span class="title">resignFirstResponder</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>重写canBecomeFirstResponder方法</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">canBecomeFirstResponder</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把歌曲详情设置到锁屏界面：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func configNowPlayingInfoCenter()&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">NSClassFromString</span>(<span class="string">"MPNowPlayingInfoCenter"</span>) != <span class="literal">nil</span>) &#123;</span><br><span class="line">	    <span class="comment">//锁屏界面图片的存储方式          </span></span><br><span class="line">		let mArt:<span class="built_in">MPMediaItemArtwork</span> = <span class="built_in">MPMediaItemArtwork</span>(image: currentSongPic)</span><br><span class="line">		<span class="comment">//锁屏界面信息字典</span></span><br><span class="line">		var dic:[String : AnyObject] = [ </span><br><span class="line">			<span class="built_in">MPMediaItemPropertyTitle</span> : currentSongTitle,</span><br><span class="line">			<span class="built_in">MPMediaItemPropertyArtist</span> : currentSongArtist,</span><br><span class="line">			<span class="built_in">MPMediaItemPropertyArtwork</span> : mArt </span><br><span class="line">		]</span><br><span class="line">     </span><br><span class="line">		<span class="comment">//获取当前播放的时间和歌曲总时长    </span></span><br><span class="line">		let time = <span class="keyword">self</span><span class="variable">.musicPlayer</span><span class="variable">.currentTime</span>()</span><br><span class="line">		let duration = <span class="keyword">self</span><span class="variable">.musicPlayer</span><span class="variable">.currentItem</span>!<span class="variable">.asset</span><span class="variable">.duration</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//把信息传递给锁屏界面</span></span><br><span class="line">		dic<span class="variable">.updateValue</span>(<span class="built_in">NSNumber</span>(<span class="keyword">double</span>: CMTimeGetSeconds(time)), forKey: <span class="built_in">MPNowPlayingInfoPropertyElapsedPlaybackTime</span> )</span><br><span class="line">		dic<span class="variable">.updateValue</span>(<span class="built_in">NSNumber</span>(<span class="keyword">double</span>: CMTimeGetSeconds(duration)), forKey: <span class="built_in">MPMediaItemPropertyPlaybackDuration</span>)</span><br><span class="line">		dic<span class="variable">.updateValue</span>(<span class="built_in">NSNumber</span>(<span class="keyword">float</span>: <span class="number">1.0</span>), forKey: <span class="built_in">MPNowPlayingInfoPropertyPlaybackRate</span>)</span><br><span class="line"></span><br><span class="line">		<span class="built_in">MPNowPlayingInfoCenter</span><span class="variable">.defaultCenter</span>()<span class="variable">.nowPlayingInfo</span> = dic</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再处理锁屏和控制中心点击事件：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">override</span> func <span class="title">remoteControlReceivedWithEvent</span>(<span class="params"><span class="keyword">event</span>: UIEvent?</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">event</span>!.type == UIEventType.RemoteControl &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">event</span>!.subtype == UIEventSubtype.RemoteControlNextTrack &#123;</span><br><span class="line">			<span class="comment">//下一曲</span></span><br><span class="line"></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">event</span>!.subtype == UIEventSubtype.RemoteControlPause&#123;</span><br><span class="line">			<span class="comment">//暂停按钮</span></span><br><span class="line"></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">event</span>!.subtype == UIEventSubtype.RemoteControlPlay&#123;</span><br><span class="line">			<span class="comment">//播放按钮</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用KVO监视播放器的缓存状态和播放状态">利用KVO监视播放器的缓存状态和播放状态</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先移除观察者      </span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">self</span>.musicPlayer.currentItem != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">self</span>.musicPlayer.currentItem?.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"status"</span>)</span><br><span class="line">	<span class="keyword">self</span>.musicPlayer.currentItem?.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"loadedTimeRanges"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加观察者</span></span><br><span class="line">playerItem.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"status"</span>, options: .<span class="type">New</span>, context: <span class="literal">nil</span>)</span><br><span class="line">playerItem.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"loadedTimeRanges"</span>, options: .<span class="type">New</span>, context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//播放状态</span></span><br><span class="line">playerItem.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"status"</span>, options: .<span class="type">New</span>, context: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//缓存进度</span></span><br><span class="line">playerItem.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"loadedTimeRanges"</span>, options: .<span class="type">New</span>, context: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性改变了要实现的方法</span></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">observeValueForKeyPath</span><span class="params">(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;)</span></span> &#123;</span><br><span class="line">	<span class="comment">//获取缓存进度</span></span><br><span class="line">	<span class="keyword">if</span> keyPath == <span class="string">"loadedTimeRanges"</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> array = (object <span class="keyword">as</span>! <span class="type">AVPlayerItem</span>).loadedTimeRanges</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> range = array.first &#123;</span><br><span class="line">			<span class="comment">//当前缓存的总时间</span></span><br><span class="line">       <span class="keyword">let</span> rangeValue = range.<span class="type">CMTimeRangeValue</span></span><br><span class="line">       <span class="keyword">let</span> duration = rangeValue.duration</span><br><span class="line">			<span class="comment">//总时间换算成秒数</span></span><br><span class="line">       <span class="keyword">let</span> loadTime = <span class="type">CMTimeGetSeconds</span>(duration)</span><br><span class="line"></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">//获取当前播放状态</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>获取到了缓存时间可以判断当前的缓存时间和当前播放时间的值，来判断网络状况，同时也可以在做视频播放器时用来作缓存条</em>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在iOS开发中，AVAudioPlayer不是不能播放在线音频的，要播放在线音频只能用以下几个方法：</p>
<ul>
<li>AVPlayer </li>
<li>MPMoviePlayerController 能实现音乐流播（但是此方法苹果在iOS9中已经不推荐使用了）]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 常用第三方库7(Reachability)]]></title>
    <link href="http://xinnyu.com/2015/09/21/iOS-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%937-Reachability/"/>
    <id>http://xinnyu.com/2015/09/21/iOS-常用第三方库7-Reachability/</id>
    <published>2015-09-20T16:06:47.000Z</published>
    <updated>2015-09-26T17:15:40.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/tonymillion/Reachability" target="_blank" rel="external">Reachability</a> 是一个检测网络状态的框架。<br>开发Web等网络应用程序的时候，需要确认网络环境，连接情况等信息。如果没有处理这些信息的话，是不会通过Apple的审查的。</p>
<h3 id="使用方法：">使用方法：</h3><p>将Reachability.h 和 Reachability.m 拷贝到你的工程中。</p>
<p>然后：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reach:<span class="type">Reachability</span>?</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">checkNetStatus</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">self</span>.reach = <span class="type">Reachability</span>.reachabilityForInternetConnection()</span><br><span class="line">       <span class="comment">// Tell the reachability that we DON'T want to be reachable on 3G/EDGE/CDMA</span></span><br><span class="line">       <span class="keyword">self</span>.reach!.reachableOnWWAN = <span class="literal">false</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> reach?.currentReachabilityStatus() == <span class="type">NetworkStatus</span>.<span class="type">ReachableViaWWAN</span> &#123;</span><br><span class="line">           <span class="keyword">self</span>.net = <span class="type">NetState</span>.<span class="type">Mobile</span></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// Here we set up a NSNotification observer. The Reachability that caused the notification</span></span><br><span class="line">       <span class="comment">// is passed in the object parameter</span></span><br><span class="line">       <span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>,</span><br><span class="line">           selector: <span class="string">"reachabilityChanged:"</span>,</span><br><span class="line">           name: kReachabilityChangedNotification,</span><br><span class="line">           object: <span class="literal">nil</span>)</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">self</span>.reach!.startNotifier()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="func"><span class="keyword">func</span> <span class="title">reachabilityChanged</span><span class="params">(notification: NSNotification)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">self</span>.reach!.isReachableViaWiFi()  &#123;</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">"能访问网络"</span>)</span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>  <span class="keyword">self</span>.reach!.isReachableViaWWAN()&#123;</span><br><span class="line">           appDelegate.isCanUseNetWork = <span class="literal">true</span></span><br><span class="line">           <span class="built_in">print</span>(<span class="string">"正在使用移动网络"</span>)</span><br><span class="line">           </span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           </span><br><span class="line">           <span class="built_in">print</span>(<span class="string">"没有网络!!!"</span>) </span><br><span class="line">           <span class="keyword">self</span>.net = <span class="type">NetState</span>.<span class="type">None</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/tonymillion/Reachability" target="_blank" rel="external">Reachability</a> 是一个检测网络状态的框架。<br>开发Web等网络应用程序的时候，需要]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 常用第三方库7(SDWebImage)]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%937-SDWebImage/"/>
    <id>http://xinnyu.com/2015/09/20/iOS-常用第三方库7-SDWebImage/</id>
    <published>2015-09-20T15:45:43.000Z</published>
    <updated>2015-09-20T16:04:18.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a>是一个著名的第三方库，它的作用是：</p>
<blockquote>
<p>Asynchronous image downloader with cache support with an UIImageView category.<br>就是一个异步加载图片并且支持缓存的UIImage分类；</p>
</blockquote>
<h3 id="使用方法：">使用方法：</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">imageView.<span class="function"><span class="title">sd_setImageWithURL</span><span class="params">(NSURL(string: <span class="string">""</span>)</span></span>, placeholderImage: <span class="function"><span class="title">UIImage</span><span class="params">(named: <span class="string">"placeholder"</span>)</span></span>)</span><br></pre></td></tr></table></figure>
<p>清除缓存：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">SDImageCache.<span class="function"><span class="title">sharedImageCache</span><span class="params">()</span></span>.<span class="function"><span class="title">cleanDisk</span><span class="params">()</span></span></span><br><span class="line">SDImageCache.<span class="function"><span class="title">sharedImageCache</span><span class="params">()</span></span>.<span class="function"><span class="title">clearMemory</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>这个框架使用简单，然而而其中复杂的实现细节全部隐藏在这行代码之后；这边有一篇它的源代码分析：<a href="">http://draveness.me/ios-yuan-dai-ma-jie-xi-sdwebimage/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a>是一个著名的第三方库，它的作用是：</p>
<blockquote>
<p>Asynchronou]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 常用第三方库6(POP动画)]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%936-POP%E5%8A%A8%E7%94%BB/"/>
    <id>http://xinnyu.com/2015/09/20/iOS-常用第三方库6-POP动画/</id>
    <published>2015-09-20T14:53:46.000Z</published>
    <updated>2015-09-26T14:40:41.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/facebook/pop" target="_blank" rel="external">POP</a>是Facebook公司的一个开源项目，它是一个完全不同于Core Animation的动画引擎；它在基本的静态动画的基础上增加的弹簧动画与衰减动画 使之能创造出更真实更具物理性的交互动画 POP的API可以快速的与现有的ObjC代码集成并可以作用于任意对象的任意属性，POP是个相当成熟且久经考验的框架，Facebook出品的令人惊叹的Paper应用中的所有动画和效果即出自POP。</p>
<h3 id="使用方式：">使用方式：</h3><p>POP默认支持三种动画 但同时也支持自定义动画</p>
<ul>
<li>POPBasicAnimation</li>
<li>POPSpringAnimation</li>
<li>POPDecayAnimation</li>
<li>POPCustomAnimation //自定义动画</li>
</ul>
<p>这里我们只讨论前三种，因为自定义动画还没用过；</p>
<h4 id="代码示例：">代码示例：</h4><p><strong>BasicAnimation</strong><br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">let rotation = POPBasicAnimation(<span class="string">propertyNamed:</span> kPOPLayerRotation[^POP动画的参数])</span><br><span class="line">rotation.toValue = M_PI * <span class="number">2</span></span><br><span class="line">rotation.duration = <span class="number">10</span></span><br><span class="line">rotation.repeatForever = <span class="literal">true</span></span><br><span class="line">rotation.timingFunction = CAMediaTimingFunction(<span class="string">name:</span> kCAMediaTimingFunctionLinear)</span><br><span class="line">        </span><br><span class="line">self.layer.pop_addAnimation(rotation, <span class="string">forKey:</span> <span class="string">"旋转"</span>)</span><br></pre></td></tr></table></figure></p>
<p>POPBasicAnimation提供四种时间曲线,这个和Core Animation中的是一样的：</p>
<ul>
<li>kCAMediaTimingFunctionLinear</li>
<li>kCAMediaTimingFunctionEaseIn</li>
<li>kCAMediaTimingFunctionEaseOut</li>
<li>kCAMediaTimingFunctionEaseInEaseOut</li>
</ul>
<p><strong>POPSpringAnimation</strong><br>弹性动画</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化POP</span></span><br><span class="line">let scale = <span class="function"><span class="title">POPSpringAnimation</span><span class="params">(propertyNamed:kPOPViewScaleXY)</span></span></span><br><span class="line"><span class="comment">//设置结束值</span></span><br><span class="line">scale<span class="class">.toValue</span> = <span class="function"><span class="title">NSValue</span><span class="params">(CGPointMake(<span class="number">2</span>,<span class="number">2</span>)</span></span>)</span><br><span class="line"><span class="comment">//振幅，范围0-20</span></span><br><span class="line">scale<span class="class">.springBounciness</span> = <span class="number">20</span></span><br><span class="line"><span class="comment">//振动速度,范围0-20</span></span><br><span class="line">scale<span class="class">.springSpeed</span> = <span class="number">1</span></span><br><span class="line">view<span class="class">.layer</span><span class="class">.pop_addAnimatiom</span>(scale,foKey:<span class="string">"scale"</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>弹性动画可配置的属性有：</p>
<ul>
<li>springBounciness:4.0    //[0-20] 弹力 越大则震动幅度越大</li>
<li>springSpeed     :12.0   //[0-20] 速度 越大则动画结束越快</li>
<li>dynamicsTension :0      //拉力  下面这三个都跟物理力学模拟相关 数值调整起来很费时，建议就用默认值</li>
<li>dynamicsFriction:0      //摩擦 同上</li>
<li>dynamicsMass    :0      //质量 同上</li>
</ul>
</blockquote>
<p><strong>POPDecayAnimation</strong><br>阻尼动画</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POPDecayAnimation </span>*<span class="keyword">anDecay </span>= [<span class="keyword">POPDecayAnimation </span>animationWithPropertyNamed:kPOPLayerPositionX]<span class="comment">;</span></span><br><span class="line"><span class="keyword">anDecay.velocity </span>= <span class="comment">@(600);</span></span><br><span class="line"><span class="keyword">anDecay.beginTime </span>= CACurrentMediaTime() + <span class="number">1</span>.<span class="number">0</span>f<span class="comment">;</span></span><br><span class="line">[<span class="keyword">self.square </span><span class="keyword">pop_addAnimation:anDecay </span>forKey:<span class="comment">@"position"];</span></span><br></pre></td></tr></table></figure>
<p><em>注意:这里对POPDecayAnimation设置toValue是没有意义的 会被忽略(因为目的状态是动态计算得到的</em>)</p>
<blockquote>
<p>POPDecayAnimation可配置的属性与默认值有:<br>deceleration:0.998  //衰减系数(越小则衰减得越快)</p>
</blockquote>
<p><em>注意:POPDecayAnimation也是没有duration字段的 其动画持续时间由velocity与deceleration决定</em></p>
<p>POP默认支持的动画属性：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> Common CALayer property names.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerBackgroundColor;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerBounds;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerCornerRadius;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerBorderWidth;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerBorderColor;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerOpacity;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerPosition;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerPositionX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerPositionY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerRotation;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerRotationX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerRotationY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerScaleX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerScaleXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerScaleY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSize;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubscaleXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubtranslationX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubtranslationXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubtranslationY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerSubtranslationZ;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerTranslationX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerTranslationXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerTranslationY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerTranslationZ;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerZPosition;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerShadowColor;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerShadowOffset;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerShadowOpacity;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayerShadowRadius;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> Common CAShapeLayer property names.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPShapeLayerStrokeStart;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPShapeLayerStrokeEnd;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPShapeLayerStrokeColor;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPShapeLayerFillColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> Common NSLayoutConstraint property names.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLayoutConstraintConstant;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if TARGET_OS_IPHONE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> Common UIView property names.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewAlpha;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewBackgroundColor;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewBounds;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewCenter;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewFrame;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewScaleX;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewScaleXY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewScaleY;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewSize;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPViewTintColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> Common UIScrollView property names.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPScrollViewContentOffset;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPScrollViewContentSize;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPScrollViewZoomScale;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPScrollViewContentInset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> Common UITableView property names.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPTableViewContentOffset;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPTableViewContentSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> Common UICollectionView property names.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPCollectionViewContentOffset;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPCollectionViewContentSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> Common UINavigationBar property names.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPNavigationBarBarTintColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> Common UIToolbar property names.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPToolbarBarTintColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> Common UITabBar property names.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPTabBarBarTintColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> Common UILabel property names.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPOPLabelTextColor;</span><br></pre></td></tr></table></figure>
<h4 id="自定义属性：">自定义属性：</h4><p>POP默认支持的三种动画都继承自POPPropertyAnimation POPPropertyAnimation中定义了一个叫property的属性( 之前没有用到它是因为POP根据不同的默认动画属性帮你生成了默认的property) 而这个property则是用来驱动POP的动画效果中的重要一环。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">POPAnimatableProperty *<span class="keyword">prop</span> = [POPAnimatableProperty propertyWithName:@<span class="string">"prop"</span> initializer:^(POPMutableAnimatableProperty *<span class="keyword">prop</span>) &#123;</span><br><span class="line">    <span class="comment">// read value</span></span><br><span class="line">    <span class="keyword">prop</span>.readBlock = ^(id obj, CGFloat values[]) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// write value</span></span><br><span class="line">    <span class="keyword">prop</span>.writeBlock = ^(id obj, <span class="keyword">const</span> CGFloat values[]) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// dynamics threshold</span></span><br><span class="line">    <span class="keyword">prop</span>.threshold = 0.01;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>其组成就是一个readBlock一个writeBlock和一个threashold</p>
<ul>
<li>readBlock告诉POP当前的属性值</li>
<li>writeBlock中修改变化后的属性值</li>
<li>threashold决定了动画变化间隔的阈值 值越大writeBlock的调用次数越少</li>
<li>POPAnimatableProperty其实是POP中一个比较重要的东西,像上面提到的POP自带的动画属性 查看源代码可以看到也只是POP自动帮你设置好了POPAnimatableProperty而已,其作用就是当动画的某个时间片被触发时,告诉系统如何根据当前时间片做出变化.</li>
</ul>
<p>下面是一个秒表动画，是利用自定义属性的POP做出来的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">POPAnimatableProperty *prop = [POPAnimatableProperty propertyWithName:@<span class="string">"countdown"</span> initializer:^(POPMutableAnimatableProperty *prop) &#123;</span><br><span class="line">        </span><br><span class="line">        prop.writeBlock = ^(id obj, <span class="keyword">const</span> CGFloat values[]) &#123;</span><br><span class="line">            UILabel *lable = (UILabel*)obj;</span><br><span class="line">            label.text = [NSString stringWithFormat:@<span class="string">"%02d:%02d:%02d"</span>,(<span class="keyword">int</span>)values[<span class="number">0</span>]/<span class="number">60</span>,(<span class="keyword">int</span>)values[<span class="number">0</span>]%<span class="number">60</span>,(<span class="keyword">int</span>)(values[<span class="number">0</span>]*<span class="number">100</span>)%<span class="number">100</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        prop.threshold = 0.01f;</span></span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    POPBasicAnimation *anBasic = [POPBasicAnimation linearAnimation];   <span class="comment">//秒表当然必须是线性的时间函数</span></span><br><span class="line">    anBasic.property = prop;    <span class="comment">//自定义属性</span></span><br><span class="line">    anBasic.fromValue = @(<span class="number">0</span>);   <span class="comment">//从0开始</span></span><br><span class="line">    anBasic.toValue = @(<span class="number">3</span>*<span class="number">60</span>);  <span class="comment">//180秒</span></span><br><span class="line">    anBasic.duration = <span class="number">3</span>*<span class="number">60</span>;    <span class="comment">//持续3分钟</span></span><br><span class="line">    anBasic.beginTime = CACurrentMediaTime() + <span class="number">1.0f</span>;    <span class="comment">//延迟1秒开始</span></span><br><span class="line">    [label pop_addAnimation:anBasic forKey:@<span class="string">"countdown"</span>];</span><br></pre></td></tr></table></figure>
<p>出处：<a href="http://adad184.com/2015/03/11/intro-to-pop/" target="_blank" rel="external">http://adad184.com/2015/03/11/intro-to-pop/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/facebook/pop" target="_blank" rel="external">POP</a>是Facebook公司的一个开源项目，它是一个完全不同于Core Animation的动画引擎；它在基本的静态动画]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 常用第三方库5(PNChart)]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%935-PNChart/"/>
    <id>http://xinnyu.com/2015/09/20/iOS-常用第三方库5-PNChart/</id>
    <published>2015-09-20T14:24:43.000Z</published>
    <updated>2015-09-26T15:26:34.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="external">PNChart</a> 是一个简约，易用的第三方图表库，它支持折线图，柱形图，饼状图和圆形图的绘制；</p>
<h3 id="使用方法">使用方法</h3><ul>
<li>画折线图</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span>  <span class="title">setLineChart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">  <span class="comment">/// 定义一个lineChart    </span></span><br><span class="line">	<span class="keyword">var</span> lineChart = <span class="type">PNLineChart</span>(frame: <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="keyword">self</span>.view.frame.height/<span class="number">4</span>, <span class="keyword">self</span>.view.frame.width, <span class="keyword">self</span>.view.frame.height/<span class="number">2</span>))</span><br><span class="line">	<span class="comment">//不要使用下面的方法，Width 不好计算，只设置数据的话宽度会自动设定</span></span><br><span class="line">	<span class="comment">//lineChart.setXLabels(["A","B","C","D","E","F"], withWidth: 50)</span></span><br><span class="line">	lineChart.xLabels = [<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>,<span class="string">"F"</span>]</span><br><span class="line">	lineChart.axisColor = <span class="type">UIColor</span>.blackColor()</span><br><span class="line">	lineChart.showCoordinateAxis = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">	<span class="comment">/// 设置第一根折线</span></span><br><span class="line">	<span class="keyword">var</span> dataArray = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">	<span class="keyword">var</span> lineChartData = <span class="type">PNLineChartData</span>()</span><br><span class="line">	<span class="comment">//lineChartData.lineWidth = 20</span></span><br><span class="line">	lineChartData.itemCount = <span class="type">UInt</span>(dataArray.<span class="built_in">count</span>)</span><br><span class="line">	lineChartData.color = <span class="type">UIColor</span>.greenColor()</span><br><span class="line">	lineChartData.getData = (&#123;(index:<span class="type">UInt</span>) -&gt; <span class="type">PNLineChartDataItem</span> <span class="keyword">in</span></span><br><span class="line">	<span class="keyword">var</span> y = dataArray[<span class="type">Int</span>(index)]</span><br><span class="line">	<span class="keyword">return</span> <span class="type">PNLineChartDataItem</span>(y: <span class="type">CGFloat</span>(y))</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//为数据源设置Title</span></span><br><span class="line">	lineChartData.dataTitle = <span class="string">"Swift"</span></span><br><span class="line">        </span><br><span class="line">	<span class="comment">/// 设置第二根折线</span></span><br><span class="line">	<span class="keyword">var</span> dataArray2 = [<span class="number">5</span>,<span class="number">19</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">	<span class="keyword">var</span> lineChartData2 = <span class="type">PNLineChartData</span>()</span><br><span class="line">	<span class="comment">//lineChartData.lineWidth = 20</span></span><br><span class="line">	lineChartData2.itemCount = <span class="type">UInt</span>(dataArray2.<span class="built_in">count</span>)</span><br><span class="line">	lineChartData2.color = <span class="type">UIColor</span>.redColor()</span><br><span class="line">	lineChartData2.getData = (&#123;(index:<span class="type">UInt</span>) -&gt; <span class="type">PNLineChartDataItem</span> <span class="keyword">in</span></span><br><span class="line">		<span class="keyword">var</span> y = dataArray2[<span class="type">Int</span>(index)]</span><br><span class="line">		<span class="keyword">return</span> <span class="type">PNLineChartDataItem</span>(y: <span class="type">CGFloat</span>(y))</span><br><span class="line">	&#125;)</span><br><span class="line">        </span><br><span class="line">	<span class="comment">//把折线加入到lineChart中，开始画图</span></span><br><span class="line">	lineChart.chartData = [lineChartData,lineChartData2]</span><br><span class="line">	lineChart.strokeChart()</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">self</span>.view.addSubview(lineChart)</span><br><span class="line">        </span><br><span class="line">	<span class="comment">/// 为图表设置标签，****要在画图之后添加****</span></span><br><span class="line">	<span class="comment">//为数据源2设置Title</span></span><br><span class="line">	lineChartData2.dataTitle = <span class="string">"OC"</span></span><br><span class="line">	<span class="comment">//选择标签风格</span></span><br><span class="line">	lineChart.legendStyle = <span class="type">PNLegendItemStyle</span>.<span class="type">Serial</span></span><br><span class="line">	<span class="comment">//获取标签</span></span><br><span class="line">	<span class="keyword">var</span> legend = lineChart.getLegendWithMaxWidth(<span class="keyword">self</span>.view.frame.width)</span><br><span class="line">	<span class="comment">//设置标签位置</span></span><br><span class="line">	legend.frame = <span class="type">CGRectMake</span>(<span class="number">50</span>, lineChart.frame.origin.y + lineChart.frame.height + <span class="number">10</span> , legend.frame.width, legend.frame.height)</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">self</span>.view.addSubview(legend)</span><br><span class="line">        </span><br><span class="line">	lineChart.delegate = <span class="keyword">self</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>画柱形图：</li>
</ul>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">func setBarChart()&#123;</span><br><span class="line">	//直接初始化一个PNBarChart，不要数据源</span><br><span class="line">	var barChart = PNBarChart(frame: CGRectMake(0, 200, self.view.frame.width, 350))</span><br><span class="line">	barChart.xLabels = [<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>]</span><br><span class="line">	//barChart.xLabelWidth = 55</span><br><span class="line">	barChart.yValues = [1,3,6,-7,15]</span><br><span class="line">	//显示图表边界</span><br><span class="line">	barChart.showChartBorder = true</span><br><span class="line">	//允许负数</span><br><span class="line">	barChart.showLevelLine = false</span><br><span class="line">        </span><br><span class="line">	//barChart.strokeColor = UIColor.redColor()</span><br><span class="line">	barChart.barRadius = 2</span><br><span class="line">	//设置文字颜色，<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>设置不了<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">	barChart.labelTextColor = UIColor.redColor()</span><br><span class="line">        </span><br><span class="line">	//开始画图</span><br><span class="line">	barChart.strokeChart()</span><br><span class="line">	self.view.add</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>画圆形图：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">setCircleChart</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//直接初始化一个PNCircleChart ，不要数据源之类的</span></span><br><span class="line">	var circelChart = PNCircleChart(frame: CGRectMake(self.view.frame.width/<span class="number">2</span> - self.view.frame.width/<span class="number">4</span>, <span class="number">200</span>, self.view.frame.width/<span class="number">2</span>, <span class="number">200</span>), total: <span class="number">100</span>, current: <span class="number">60</span>, clockwise: <span class="literal">false</span>, shadow: <span class="literal">true</span>, shadowColor: UIColor.grayColor())</span><br><span class="line">	circelChart.current = <span class="number">60</span></span><br><span class="line">	circelChart.total = <span class="number">100</span></span><br><span class="line">	<span class="comment">//circelChart.strokeColor = UIColor.greenColor()</span></span><br><span class="line">        </span><br><span class="line">	circelChart.strokeChart()</span><br><span class="line">	self.view.addSubview(circelChart)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>画饼状图：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">func <span class="title">setPieChart</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//先定义一个PNPieChartDataItem数组，116 202 33      72 114 224</span></span><br><span class="line">	var items = [PNPieChartDataItem(value: <span class="number">50</span>, color: UIColor(red: <span class="number">116</span>/<span class="number">255</span>, green: <span class="number">202</span>/<span class="number">255</span>, blue: <span class="number">33</span>/<span class="number">255</span>, alpha: <span class="number">1</span>) , description: <span class="string">"Swift"</span>),PNPieChartDataItem(value: <span class="number">20</span>, color: UIColor(red: <span class="number">72</span>/<span class="number">255</span>, green: <span class="number">114</span>/<span class="number">255</span>, blue: <span class="number">224</span>/<span class="number">255</span>, alpha: <span class="number">1</span>) , description: <span class="string">"OC"</span>)]</span><br><span class="line">        </span><br><span class="line">	var pieChart = PNPieChart(frame: CGRectMake(self.view.frame.width/<span class="number">2</span> - self.view.frame.width/<span class="number">3</span>, <span class="number">200</span>, self.view.frame.width/<span class="number">1.5</span>, <span class="number">200</span>), items: items)</span><br><span class="line">        </span><br><span class="line">	pieChart.descriptionTextFont = UIFont.systemFontOfSize(<span class="number">15</span>)</span><br><span class="line">        </span><br><span class="line">	pieChart.strokeChart()</span><br><span class="line">	self.view.addSubview(pieChart)</span><br><span class="line">        </span><br><span class="line">	<span class="comment">//选择标签风格</span></span><br><span class="line">	pieChart.legendStyle = PNLegendItemStyle.Serial</span><br><span class="line">	<span class="comment">//获取标签</span></span><br><span class="line">	var legend = pieChart.getLegendWithMaxWidth(self.view.frame.width)</span><br><span class="line">	<span class="comment">//设置标签位置</span></span><br><span class="line">	legend.frame = CGRectMake(<span class="number">50</span>, pieChart.frame.origin.y + pieChart.frame.height + <span class="number">10</span>, legend.frame.width, legend.frame.height)</span><br><span class="line">        </span><br><span class="line">	self.view.addSubview(legend)     </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/kevinzhow/PNChart" target="_blank" rel="external">PNChart</a> 是一个简约，易用的第三方图表库，它支持折线图，柱形图，饼状图和圆形图的绘制；</p>
<h3 ]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS-常用第三方库4(SwiftyJSON)]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%934-SwiftyJSON/"/>
    <id>http://xinnyu.com/2015/09/20/iOS-常用第三方库4-SwiftyJSON/</id>
    <published>2015-09-20T14:14:38.000Z</published>
    <updated>2015-09-20T14:22:58.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="external">SwiftJSON</a>是用Swift写的一个快速处理JSON数据的第三方库。</p>
<h3 id="使用方法：">使用方法：</h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> json = JSON(data: dataFromNetworking)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> userName = json[<span class="string">"name"</span>].<span class="keyword">string</span>&#123;</span><br><span class="line">  <span class="comment">//就这么简单取到了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://tangplin.github.io/swiftyjson/" target="_blank" rel="external">中文说明</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="external">SwiftJSON</a>是用Swift写的一个快速处理JSON数据的第三方库。</p>
<h3 id="使用]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS-常用第三方库3(HUD)]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%933-HUD/"/>
    <id>http://xinnyu.com/2015/09/20/iOS-常用第三方库3-HUD/</id>
    <published>2015-09-20T12:21:18.000Z</published>
    <updated>2015-09-26T16:11:12.000Z</updated>
    <content type="html"><![CDATA[<p>GitHub上iOS关于HUD的第三方库实在太多了， 这三个比较常用：</p>
<ul>
<li><a href="https://github.com/relatedcode/ProgressHUD" target="_blank" rel="external">ProgressHUD</a></li>
<li><a href="https://github.com/johnlui/SwiftNotice" target="_blank" rel="external">SwiftNotice</a></li>
<li><a href="https://github.com/jdg/MBProgressHUD/tree/iOS7Style" target="_blank" rel="external">MBProgressHUD</a></li>
</ul>
<h3 id="ProgressHUD">ProgressHUD</h3><p>用法简单，一行代码搞定：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="id">#import</span> <span class="string">"ProgressHUD.h"</span></span><br><span class="line"></span><br><span class="line">ProgressHUD.<span class="function"><span class="title">show</span><span class="params">(<span class="string">"正在刷新！"</span>)</span></span></span><br><span class="line">ProgressHUD.<span class="function"><span class="title">showError</span><span class="params">(<span class="string">"错误"</span>)</span></span></span><br><span class="line">ProgressHUD.<span class="function"><span class="title">showSuccess</span><span class="params">(<span class="string">"刷新成功！"</span>)</span></span></span><br><span class="line"></span><br><span class="line">ProgressHUD.<span class="function"><span class="title">dismiss</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>但是可自定义的属性不多；</p>
<h3 id="SwiftNotice">SwiftNotice</h3><p>用法同样简单，还支持顶部通知：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">noticeTop</span><span class="params">(<span class="string">""</span>)</span></span> <span class="comment">//顶部通知</span></span><br><span class="line"><span class="function"><span class="title">notice</span><span class="params">(<span class="string">""</span>, type: NoticeType, autoClear: true)</span></span></span><br><span class="line"><span class="function"><span class="title">noticeOnlyText</span><span class="params">(<span class="string">""</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">successNotice</span><span class="params">(<span class="string">""</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">errorNotice</span><span class="params">(<span class="string">""</span>)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="MBProgressHUD">MBProgressHUD</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attr_selector">[MBProgressHUD showHUDAddedTo:self.view animated:YES]</span>;</span><br><span class="line"><span class="tag">dispatch_async</span>(<span class="function">dispatch_get_global_queue</span>( DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// Do something...</span></span><br><span class="line">    <span class="tag">dispatch_async</span>(<span class="function">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">        <span class="attr_selector">[MBProgressHUD hideHUDForView:self.view animated:YES]</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>自定义：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">MBProgressHUD *hud = [MBProgressHUD <span class="string">showHUDAddedTo:</span>self.view <span class="string">animated:</span>YES];</span><br><span class="line">hud.mode = MBProgressHUDModeAnnularDeterminate;</span><br><span class="line">hud.labelText = @<span class="string">"Loading"</span>;</span><br><span class="line">[self <span class="string">doSomethingInBackgroundWithProgressCallback:</span>^(<span class="typename">float</span> progress) &#123;</span><br><span class="line">    hud.progress = progress;</span><br><span class="line">&#125; <span class="string">completionCallback:</span>^&#123;</span><br><span class="line">    [hud <span class="string">hide:</span>YES];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>GitHub上iOS关于HUD的第三方库实在太多了， 这三个比较常用：</p>
<ul>
<li><a href="https://github.com/relatedcode/ProgressHUD" target="_blank" rel="external">Prog]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS-常用第三方库2(MJRefresh)]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%932-MJRefresh/"/>
    <id>http://xinnyu.com/2015/09/20/iOS-常用第三方库2-MJRefresh/</id>
    <published>2015-09-20T11:52:32.000Z</published>
    <updated>2015-09-26T16:46:55.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="external">MJRefresh</a>是用法最简单的下拉刷新框架：一行代码搞定 </p>
<p>支持 UIScrollView、UITableView、UICollectionView、UIWebView 的刷新</p>
<h3 id="基础用法">基础用法</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置下拉刷新</span></span><br><span class="line"><span class="keyword">var</span> <span class="type">MJHeader</span> = <span class="type">MJRefreshNormalHeader</span>(refreshingTarget: <span class="keyword">self</span>, refreshingAction: <span class="string">"refresh"</span>)</span><br><span class="line"><span class="keyword">self</span>.myTabView.header = <span class="type">MJHeader</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//设置上拉加载</span></span><br><span class="line"><span class="keyword">var</span> <span class="type">MJFooter</span> = <span class="type">MJRefreshAutoNormalFooter</span>(refreshingTarget: <span class="keyword">self</span>, refreshingAction: <span class="string">"load"</span>)</span><br><span class="line"><span class="keyword">self</span>.myTabView.footer = <span class="type">MJFooter</span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">load</span><span class="params">()</span></span>&#123;  </span><br><span class="line">	<span class="comment">//执行加载动作</span></span><br><span class="line">	<span class="keyword">self</span>.myTabView.header.endRefreshing()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">refresh</span><span class="params">()</span></span>&#123;  </span><br><span class="line">	<span class="comment">//执行刷新动作</span></span><br><span class="line">	<span class="keyword">self</span>.myTabView.footer.endRefreshing()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高级用法">高级用法</h3><ol>
<li><p>下拉刷新控件的种类</p>
<p> ○ 默认（Normal）：MJRefreshNormalHeader<br> ○ 动图（Gif）：MJRefreshGifHeader</p>
</li>
<li><p>上拉刷新控件的种类</p>
<p> <em>自动刷新（Auto）</em><br> 默认（Normal）：MJRefreshAutoNormalFooter<br> 动图（Gif）：MJRefreshAutoGifFooter<br> <em>自动回弹（Back）</em><br> 默认（Normal）：MJRefreshBackNormalFooter<br> 动图（Gif）：MJRefreshBackGifFooter</p>
</li>
</ol>
<p>####<br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">// 设置文字</span><br><span class="line">[header <span class="built_in">set</span>Title:@<span class="string">"Pull down to refresh"</span> <span class="keyword">for</span>State:MJRefreshStateIdle];</span><br><span class="line">[header <span class="built_in">set</span>Title:@<span class="string">"Release to refresh"</span> <span class="keyword">for</span>State:MJRefreshStatePulling];</span><br><span class="line">[header <span class="built_in">set</span>Title:@<span class="string">"Loading ..."</span> <span class="keyword">for</span>State:MJRefreshStateRefreshing];</span><br><span class="line">// 设置字体</span><br><span class="line">header.<span class="keyword">state</span>Label.font = [UIFont systemFontOfSize:<span class="number">15</span>];</span><br><span class="line">header.lastUpdatedTimeLabel.font = [UIFont systemFontOfSize:<span class="number">14</span>];</span><br><span class="line">// 设置颜色</span><br><span class="line">header.<span class="keyword">state</span>Label.textColor = [UIColor redColor];</span><br><span class="line">header.lastUpdatedTimeLabel.textColor = [UIColor blueColor];</span><br><span class="line"></span><br><span class="line">// 隐藏时间</span><br><span class="line">header.lastUpdatedTimeLabel.hidden = YES;</span><br><span class="line">// 隐藏状态</span><br><span class="line">header.<span class="keyword">state</span>Label.hidden = YES;</span><br></pre></td></tr></table></figure></p>
<h4 id="下拉加载">下拉加载</h4><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">// 设置回调（一旦进入刷新状态，就调用target的action，也就是调用<span class="literal">self</span>的<span class="built_in">load</span>MoreData方法）</span><br><span class="line">MJRefreshAutoGifFooter *footer = [MJRefreshAutoGifFooter footerWithRefreshingTarget:<span class="literal">self</span> refreshingAction:@selector(<span class="built_in">load</span>MoreData)];</span><br><span class="line">// 设置刷新图片</span><br><span class="line">[footer <span class="built_in">set</span>Images:refreshingImages <span class="keyword">for</span>State:MJRefreshStateRefreshing];</span><br><span class="line"></span><br><span class="line">// 隐藏刷新状态的文字</span><br><span class="line">footer.refreshingTitleHidden = YES;</span><br><span class="line">// 如果没有上面的方法，就用footer.<span class="keyword">state</span>Label.hidden = YES;</span><br><span class="line"></span><br><span class="line">// 隐藏当前的上拉刷新控件</span><br><span class="line"><span class="literal">self</span>.<span class="built_in">table</span>View.footer.hidden = YES;</span><br><span class="line"></span><br><span class="line">// 变为没有更多数据的状态</span><br><span class="line">[footer noticeNoMoreData];</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="external">MJRefresh</a>是用法最简单的下拉刷新框架：一行代码搞定 </p>
<p>支持 UIScrollVie]]>
    </summary>
    
      <category term="第三方库，iOS，Swift" scheme="http://xinnyu.com/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%EF%BC%8CiOS%EF%BC%8CSwift/"/>
    
      <category term="iOS" scheme="http://xinnyu.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 常用第三方库1(Alamofire)]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS-%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%931(Alamofire)/"/>
    <id>http://xinnyu.com/2015/09/20/iOS-常用第三方库1(Alamofire)/</id>
    <published>2015-09-20T11:18:20.000Z</published>
    <updated>2015-09-26T09:36:02.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="external">Alamofire</a> 是Swift版的 AFNetworking，是非常方便实用的第三方网络操作框架；</p>
<h3 id="使用方法：">使用方法：</h3><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">Alamofire.request(<span class="function"><span class="keyword">method</span>:</span> <span class="function"><span class="keyword">Method</span>, <span class="title">URLString</span>:</span> URLStringConvertible, parameters: [String : AnyObject]?, encoding: ParameterEncoding, headers: [String : String]?).response (options: NSJSONReadingOptions, completionHandler: <span class="comment">&#123; (NSURLRequest, NSHTTPURLResponse?, NSData?, NSError?) -&gt; Void in</span><br><span class="line">    //操作数据</span><br><span class="line"></span><br><span class="line">&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>但是上面方法中有些参数可以省略，基本用法如下：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">Alamofire.request<span class="function"><span class="params">(.GET, <span class="string">"URL"</span>)</span>.<span class="title">responseJSON</span><span class="params">(options: NSJSONReadingOptions.AllowFragments)</span> &#123; <span class="params">(_, _, json, _)</span> -&gt;</span> Void <span class="keyword">in</span></span><br><span class="line"><span class="pi">//操作数据</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="获取数据的方法">获取数据的方法</h4><ul>
<li>response()</li>
<li>responseString(encoding: NSStringEncoding)</li>
<li>responseJSON(options: NSJSONReadingOptions)</li>
<li>responsePropertyList(options: NSPropertyListReadOptions)</li>
</ul>
<h4 id="HTTP_Methods">HTTP Methods</h4><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">public enum Method: String &#123;</span><br><span class="line">    case OPTIONS = <span class="string">"<span class="keyword">OPTIONS</span>"</span></span><br><span class="line">    case GET = <span class="string">"<span class="keyword">GET</span>"</span></span><br><span class="line">    case HEAD = <span class="string">"<span class="keyword">HEAD</span>"</span></span><br><span class="line">    case POST = <span class="string">"<span class="keyword">POST</span>"</span></span><br><span class="line">    case PUT = <span class="string">"<span class="keyword">PUT</span>"</span></span><br><span class="line">    case PATCH = <span class="string">"<span class="keyword">PATCH</span>"</span></span><br><span class="line">    case DELETE = <span class="string">"<span class="keyword">DELETE</span>"</span></span><br><span class="line">    case TRACE = <span class="string">"<span class="keyword">TRACE</span>"</span></span><br><span class="line">    case CONNECT = <span class="string">"<span class="keyword">CONNECT</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="请求需要的参数parameters">请求需要的参数parameters</h4><p>类型是一个字典 [String : AnyObject]<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let parameters = [</span><br><span class="line">    <span class="string">"foo"</span>: <span class="string">"bar"</span>,</span><br><span class="line">    <span class="string">"baz"</span>: [<span class="string">"a"</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="string">"qux"</span>: [<span class="string">"x"</span>: <span class="number">1</span> , <span class="string">"y"</span>: <span class="number">2</span> , <span class="string">"z"</span>: <span class="number">3</span>]</span><br><span class="line">]</span><br><span class="line">Alamofire.request(.POST, <span class="string">"http://httpbin.org/post"</span>, parameters: parameters)</span><br></pre></td></tr></table></figure></p>
<h4 id="下载文件">下载文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Alamofire.download(.GET, <span class="string">"http://httpbin.org/stream/100"</span>) &#123; temporaryURL, response <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">let</span> fileManager = NSFileManager.defaultManager()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">let</span> directoryURL = fileManager.URLsForDirectory(.DocumentDirectory, <span class="keyword">in</span>Domains: .UserDomainMask)[<span class="number">0</span>] as? NSURL &#123;</span><br><span class="line">        <span class="built_in">let</span> pathComponent = response.suggestedFilename</span><br><span class="line">        <span class="built_in">return</span> directoryURL.URLByAppendingPathComponent(pathComponent!)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> temporaryURL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这些都只是Alamofire的常规使用，更加详细的使用方法其官方网站上有详细描述。</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="external">Alamofire</a> 是Swift版的 AFNetworking，是非常方便实用的第三方网络操作框架；</p]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS9 网络https 错误]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS9-%E7%BD%91%E7%BB%9Chttps-%E9%94%99%E8%AF%AF/"/>
    <id>http://xinnyu.com/2015/09/20/iOS9-网络https-错误/</id>
    <published>2015-09-20T11:05:25.000Z</published>
    <updated>2015-09-20T11:07:02.000Z</updated>
    <content type="html"><![CDATA[<p>在iOS9 中，苹果将原http协议改成了https协议，使用 TLS1.2 SSL加密请求数据。</p>
<p><strong>解决办法</strong>：</p>
<p>在<em>info.plist</em>中添加<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="title">key</span>&gt;</span><span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">key</span>&gt;</span>NSAllowsArbitraryLoads<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">true</span>/&gt;</span><span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在iOS9 中，苹果将原http协议改成了https协议，使用 TLS1.2 SSL加密请求数据。</p>
<p><strong>解决办法</strong>：</p>
<p>在<em>info.plist</em>中添加<br><figure class="highligh]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[CocoaPods安装使用方法]]></title>
    <link href="http://xinnyu.com/2015/09/20/CocoaPods%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://xinnyu.com/2015/09/20/CocoaPods安装使用方法/</id>
    <published>2015-09-20T10:06:32.000Z</published>
    <updated>2015-09-20T11:04:18.000Z</updated>
    <content type="html"><![CDATA[<h3 id="安装">安装</h3><p>首先安装好Ruby环境，在终端中输入以下命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo gem <span class="keyword">install</span> cocoapods</span><br></pre></td></tr></table></figure>
<p>可是在天朝，在终端中敲入这个命令之后，会发现半天没有任何反应。原因无他，因为那堵墙阻挡了cocoapods.org。</p>
<p>我们可以用淘宝的Ruby镜像来访问cocoapods。按照下面的顺序在终端中敲入依次敲入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gem sources --remove https://rubygems.org/</span><br></pre></td></tr></table></figure>
<p>等有反应之后再敲入以下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gem sources <span class="operator">-a</span> http://ruby.taobao.org/</span><br></pre></td></tr></table></figure>
<p>为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gem sources <span class="operator">-l</span></span><br></pre></td></tr></table></figure>
<p>只有在终端中出现下面文字才表明你上面的命令是成功的：</p>
<blockquote>
<p>CURRENT SOURCES ***<br><a href="http://ruby.taobao.org/" target="_blank" rel="external">http://ruby.taobao.org/</a></p>
</blockquote>
<p>这时候，再次在终端中运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo gem install cocoapods</span><br></pre></td></tr></table></figure>
<p>等上十几秒钟，CocoaPods就可以在你本地下载并且安装好了，不再需要其他设置。</p>
<h3 id="使用">使用</h3><p>e.g.<br><strong>利用CocaPods安装Alamofire</strong></p>
<p>在终端中进入（cd命令）你项目所在目录，然后在当前目录下，利用vim创建Podfile，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim Podfile</span><br></pre></td></tr></table></figure>
<p>然后在Podfile文件中输入以下文字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="string">'https://github.com/CocoaPods/Specs.git'</span></span><br><span class="line">platform :ios, <span class="string">'8.0'</span></span><br><span class="line">use_frameworks!</span><br><span class="line">pod <span class="string">'Alamofire'</span>, <span class="string">'~&gt; 2.0'</span></span><br></pre></td></tr></table></figure>
<p>这段文字可以在Alamofire的<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="external">GitHub</a>中找到；<br>然后保存退出。vim环境下，保存退出命令是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure>
<p>然后在终端中的当前项目目录下，运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod install</span><br></pre></td></tr></table></figure>
<p>然后CocoaPods就会帮你做好一切了，使用Alamofire只需要在项目中 import Alamofire；</p>
<p>对了，使用过CocoaPods的项目就不用之前的<del>.xcodeproj</del>文件打开了，而是使用<strong>.xcworkspace</strong>打开。</p>
<p>在这之后如果你还要添加新的第三方库的话，就只要在已经存在的Podfile中添加相应的代码然后到项目文件夹执行：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>pod update</span><br></pre></td></tr></table></figure>
<p><em>快速更新第三方库的方法</em>：<br>在更新时使用如下代码替换之前的 <del>pod update</del></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ pod <span class="keyword">update</span> --<span class="keyword">verbose</span> --<span class="keyword">no</span>-repo-<span class="keyword">update</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="安装">安装</h3><p>首先安装好Ruby环境，在终端中输入以下命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo g]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 传值总结]]></title>
    <link href="http://xinnyu.com/2015/09/20/iOS-%E4%BC%A0%E5%80%BC%E6%80%BB%E7%BB%93/"/>
    <id>http://xinnyu.com/2015/09/20/iOS-传值总结/</id>
    <published>2015-09-20T08:12:12.000Z</published>
    <updated>2015-09-20T09:56:36.000Z</updated>
    <content type="html"><![CDATA[<p>iOS中传值的方式主要有以下几种：</p>
<ul>
<li>segue传值</li>
<li>通知传值</li>
<li>代理传值</li>
<li>单例传值</li>
<li>ShareApplication</li>
<li>NSUserdefault</li>
</ul>
<p>如果是A页面传值到B页面，之间有segue连接的话，用属性传值就可以搞定，如果从B页面传值到A页面或者之间没有直接的segue的话，就可以使用代理传值或者单例传值了。</p>
<ul>
<li><strong>segue传值</strong></li>
</ul>
<p>segue传值就是利用segue跳转时利用属性进行传值，这边就不做记录了。</p>
<ul>
<li><strong>通知传值</strong></li>
</ul>
<p>通知是一个单例类，只存在一个通知实例，一个通知会有一个对应的名字，而这个名字就是对应的观察者的接受通知的索引，每个对象都可以接收到这个广播，但是只有这个通知的名字和观察者的名字相同时，对应的观察者才可以接收到这个广播并处理对应逻辑。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//seletor: 接收到通知后应该做的操作；name：该通知对应的名字</span></span><br><span class="line"><span class="comment">//A发送通知</span></span><br><span class="line"><span class="type">NSNotificationCenter</span>.defaultCenter().postNotificationName(<span class="string">"通知名字"</span>, object: <span class="keyword">self</span>, userInfo: [<span class="string">"key"</span>: value])</span><br><span class="line"><span class="comment">//B接收通知</span></span><br><span class="line"><span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, selector: <span class="string">"接收到通知后要执行的方法:"</span>, name: <span class="string">"通知名字"</span>, object: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//同时实现接受通知后要执行的方法</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> 接收到通知后要执行的方法<span class="params">(aNotification:NSNotification)</span></span>&#123;</span><br><span class="line">	<span class="comment">//value = aNotification.userInfo["key"]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">B</span>方 移除监听removeObserver (一定要记得)</span><br><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">		<span class="type">NSNotificationCenter</span>.defaultCenter().removeObserver(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>代理传值</strong></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明委托</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">passValueDele</span></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">passValue</span><span class="params">(value:String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受委托，并定义一个委托类的对象：</span></span><br><span class="line"><span class="keyword">let</span> vc1 = <span class="keyword">self</span>.storyboard?.instantiateViewControllerWithIdentifier(<span class="string">"detail"</span>) <span class="keyword">as</span>! <span class="type">ViewController</span></span><br><span class="line"></span><br><span class="line">vc1.delegate1 = <span class="keyword">self</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">passValue</span><span class="params">(value:String)</span></span>&#123;  </span><br><span class="line">		<span class="comment">//得到value之后执行操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在委托类中声明一个委托变量，并调用方法传值；</span></span><br><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> delegate1:passValueDele?  <span class="comment">//注意用weak，防止循环引用</span></span><br><span class="line">delegate1?.passValue(<span class="string">"value"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>单例传值</strong></li>
</ul>
<p>简单来说单例传值就是创建一个类的单例，各个ViewController共享数据。</p>
<p>先创建一个单例：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTonClass</span>: <span class="typename">NSObject &#123;</span></span></span><br><span class="line">    <span class="variable"><span class="keyword">var</span> value</span>:String?</span><br><span class="line">    struct singleTon &#123;</span><br><span class="line">        static <span class="variable"><span class="keyword">var</span> once_t</span>:dispatch_once_t = <span class="number">0</span></span><br><span class="line">        static <span class="variable"><span class="keyword">var</span> currentDataSong</span>:CurrentDataSong?</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">shareCurrentDataSong</span></span>()-&gt;CurrentDataSong&#123;</span><br><span class="line">        dispatch_once(&amp;singleTon.once_t) &#123; () -&gt; <span class="typename">Void</span> <span class="keyword">in</span></span><br><span class="line">            singleTon.SingleTonClass = SingleTonClass()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleTon.SingleTonClass!</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在需要传值的ViewController中给单例的属性赋值；<br>这样就可以在需要值的ViewController中得到要传的值了；</p>
<ul>
<li><strong>ShareAppDelegate传值</strong></li>
</ul>
<p>和单例的原理一样，不过这个单例利用的是AppDelegate；</p>
<ul>
<li><strong>NSUserdefault传值</strong></li>
</ul>
<p>此方法试用于轻量级的数据转移，就是把需要传的值先存入到NSUserdefault中，然后在需要值的地方从NSUserdefault中取值。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>iOS中传值的方式主要有以下几种：</p>
<ul>
<li>segue传值</li>
<li>通知传值</li>
<li>代理传值</li>
<li>单例传值</li>
<li>ShareApplication</li>
<li>NSUserdefault</li>
</]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[NSTimer 相关]]></title>
    <link href="http://xinnyu.com/2015/09/20/NSTimer-%E7%9B%B8%E5%85%B3/"/>
    <id>http://xinnyu.com/2015/09/20/NSTimer-相关/</id>
    <published>2015-09-20T08:06:49.000Z</published>
    <updated>2015-09-20T08:08:21.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li>定义一个 NSTimer</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">var <span class="string">timer1:</span>NSTimer! = NSTimer.scheduledTimerWithTimeInterval(<span class="number">1</span>, <span class="string">target:</span> self, <span class="string">selector:</span> <span class="string">"addOneMin:"</span>, <span class="string">userInfo:</span> nil, <span class="string">repeats:</span> <span class="literal">true</span>)</span><br><span class="line"><span class="comment">//selector 是一个选择器,需要定义一个函数,当函数需要传参时,函数名后应该加冒号</span></span><br></pre></td></tr></table></figure>
<ol>
<li>启动 NSTimer</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">.<span class="function"><span class="title">fire</span><span class="params">()</span></span></span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<ol>
<li>暂停</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">.<span class="function"><span class="title">invalidate</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li>定义一个 NSTimer</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">var <span class="strin]]>
    </summary>
    
  </entry>
  
</feed>
